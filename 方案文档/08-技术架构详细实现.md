# AIæ ‡ä¹¦æ™ºèƒ½åˆ›ä½œå¹³å° - æŠ€æœ¯æ¶æ„è¯¦ç»†å®ç°

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ·±åº¦è§£æ

### æ•´ä½“æ¶æ„æ‹“æ‰‘å›¾
```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        A[Webå‰ç«¯åº”ç”¨]
        B[ç§»åŠ¨ç«¯åº”ç”¨]
        C[æ¡Œé¢å®¢æˆ·ç«¯]
        D[å¼€æ”¾APIå®¢æˆ·ç«¯]
    end

    subgraph "APIç½‘å…³å±‚"
        E[Kong API Gateway]
        F[è®¤è¯æˆæƒæœåŠ¡]
        G[é™æµç†”æ–­]
        H[è´Ÿè½½å‡è¡¡]
    end

    subgraph "å¾®æœåŠ¡å±‚"
        I[ç”¨æˆ·æœåŠ¡]
        J[é¡¹ç›®æœåŠ¡]
        K[æ¨¡æ¿æœåŠ¡]
        L[æ–‡æ¡£æœåŠ¡]
        M[AIæœåŠ¡]
        N[åä½œæœåŠ¡]
        O[å¯¼å‡ºæœåŠ¡]
    end

    subgraph "AIèƒ½åŠ›å±‚"
        P[LLMæœåŠ¡é›†ç¾¤]
        Q[å‘é‡æ£€ç´¢æœåŠ¡]
        R[çŸ¥è¯†å›¾è°±æœåŠ¡]
        S[å·¥ä½œæµå¼•æ“]
        T[æ¨¡å‹ç®¡ç†æœåŠ¡]
    end

    subgraph "æ•°æ®å­˜å‚¨å±‚"
        U[PostgreSQLé›†ç¾¤]
        V[Redisé›†ç¾¤]
        W[MinIOå¯¹è±¡å­˜å‚¨]
        X[Pineconeå‘é‡æ•°æ®åº“]
        Y[Elasticsearch]
    end

    subgraph "åŸºç¡€è®¾æ–½å±‚"
        Z[Kubernetesé›†ç¾¤]
        AA[ç›‘æ§ç³»ç»Ÿ]
        BB[æ—¥å¿—ç³»ç»Ÿ]
        CC[CI/CDç³»ç»Ÿ]
    end

    A --> E
    B --> E
    C --> E
    D --> E

    E --> I
    E --> J
    E --> K
    E --> L
    E --> M
    E --> N
    E --> O

    M --> P
    M --> Q
    M --> R
    M --> S
    M --> T

    I --> U
    J --> U
    K --> U
    L --> U
    M --> U
    N --> U
    O --> U

    I --> V
    J --> V
    K --> V
    L --> V
    M --> V
    N --> V
    O --> V

    L --> W
    O --> W

    M --> X
    L --> Y
```

## ğŸ”§ å‰ç«¯æ¶æ„è¯¦ç»†å®ç°

### ç»„ä»¶æ¶æ„è®¾è®¡
```typescript
// ç»„ä»¶å±‚æ¬¡ç»“æ„è¯¦ç»†è®¾è®¡
src/
â”œâ”€â”€ components/                    # é€šç”¨ç»„ä»¶åº“
â”‚   â”œâ”€â”€ ui/                       # åŸºç¡€UIç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.styles.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ Button.stories.tsx
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”œâ”€â”€ Modal/
â”‚   â”‚   â”œâ”€â”€ Table/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ forms/                    # è¡¨å•ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ FormField/
â”‚   â”‚   â”œâ”€â”€ FormValidation/
â”‚   â”‚   â””â”€â”€ FormBuilder/
â”‚   â”œâ”€â”€ layout/                   # å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Header/
â”‚   â”‚   â”œâ”€â”€ Sidebar/
â”‚   â”‚   â”œâ”€â”€ Footer/
â”‚   â”‚   â””â”€â”€ MainLayout/
â”‚   â””â”€â”€ charts/                   # å›¾è¡¨ç»„ä»¶
â”‚       â”œâ”€â”€ LineChart/
â”‚       â”œâ”€â”€ BarChart/
â”‚       â””â”€â”€ PieChart/
â”œâ”€â”€ features/                     # åŠŸèƒ½æ¨¡å—
â”‚   â”œâ”€â”€ auth/                     # è®¤è¯æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”œâ”€â”€ projects/                 # é¡¹ç›®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProjectList/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProjectDetail/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProjectForm/
â”‚   â”‚   â”‚   â””â”€â”€ ProjectDashboard/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useProjects.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useProjectDetail.ts
â”‚   â”‚   â”‚   â””â”€â”€ useProjectForm.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ projectApi.ts
â”‚   â”‚   â”‚   â””â”€â”€ projectUtils.ts
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚       â”œâ”€â”€ project.types.ts
â”‚   â”‚       â””â”€â”€ projectApi.types.ts
â”‚   â”œâ”€â”€ templates/                # æ¨¡æ¿ç®¡ç†
â”‚   â”œâ”€â”€ ai-assistant/             # AIåŠ©æ‰‹
â”‚   â”œâ”€â”€ documents/                # æ–‡æ¡£ç®¡ç†
â”‚   â”œâ”€â”€ collaboration/            # åä½œåŠŸèƒ½
â”‚   â””â”€â”€ export/                   # å¯¼å‡ºåŠŸèƒ½
â”œâ”€â”€ hooks/                        # å…¨å±€Hooks
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useApi.ts
â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â””â”€â”€ useWebSocket.ts
â”œâ”€â”€ services/                     # APIæœåŠ¡
â”‚   â”œâ”€â”€ api.ts                    # APIåŸºç¡€é…ç½®
â”‚   â”œâ”€â”€ auth.ts                   # è®¤è¯æœåŠ¡
â”‚   â”œâ”€â”€ projects.ts               # é¡¹ç›®æœåŠ¡
â”‚   â”œâ”€â”€ templates.ts              # æ¨¡æ¿æœåŠ¡
â”‚   â””â”€â”€ ai.ts                     # AIæœåŠ¡
â”œâ”€â”€ stores/                       # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”œâ”€â”€ projectStore.ts
â”‚   â”œâ”€â”€ uiStore.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ utils/                        # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ constants.ts
â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”œâ”€â”€ validators.ts
â”‚   â””â”€â”€ formatters.ts
â”œâ”€â”€ types/                        # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ api.types.ts
â”‚   â”œâ”€â”€ auth.types.ts
â”‚   â”œâ”€â”€ project.types.ts
â”‚   â””â”€â”€ common.types.ts
â””â”€â”€ styles/                       # æ ·å¼æ–‡ä»¶
    â”œâ”€â”€ globals.css
    â”œâ”€â”€ variables.css
    â””â”€â”€ components/
```

### çŠ¶æ€ç®¡ç†è¯¦ç»†å®ç°
```typescript
// ä½¿ç”¨Zustandè¿›è¡ŒçŠ¶æ€ç®¡ç†
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

// è®¤è¯çŠ¶æ€ç®¡ç†
interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  permissions: Permission[];
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
  updateProfile: (profile: Partial<User>) => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  devtools(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      permissions: [],

      login: async (credentials) => {
        try {
          const response = await authService.login(credentials);
          const { user, token, permissions } = response.data;

          localStorage.setItem('token', token);

          set({
            user,
            token,
            isAuthenticated: true,
            permissions,
          });
        } catch (error) {
          throw new Error('Login failed');
        }
      },

      logout: () => {
        localStorage.removeItem('token');
        set({
          user: null,
          token: null,
          isAuthenticated: false,
          permissions: [],
        });
      },

      refreshToken: async () => {
        try {
          const response = await authService.refreshToken();
          const { token } = response.data;

          localStorage.setItem('token', token);
          set({ token });
        } catch (error) {
          get().logout();
        }
      },

      updateProfile: async (profile) => {
        const currentUser = get().user;
        if (!currentUser) return;

        const updatedUser = await authService.updateProfile(profile);
        set({ user: updatedUser.data });
      },
    }),
    { name: 'auth-store' }
  )
);

// é¡¹ç›®çŠ¶æ€ç®¡ç†
interface ProjectState {
  projects: Project[];
  currentProject: Project | null;
  loading: boolean;
  error: string | null;
  filters: ProjectFilters;
  pagination: Pagination;

  // Actions
  fetchProjects: (params?: FetchProjectsParams) => Promise<void>;
  fetchProject: (id: string) => Promise<void>;
  createProject: (project: CreateProjectData) => Promise<void>;
  updateProject: (id: string, project: UpdateProjectData) => Promise<void>;
  deleteProject: (id: string) => Promise<void>;
  setFilters: (filters: Partial<ProjectFilters>) => void;
  setPagination: (pagination: Partial<Pagination>) => void;
}

export const useProjectStore = create<ProjectState>()(
  devtools(
    (set, get) => ({
      projects: [],
      currentProject: null,
      loading: false,
      error: null,
      filters: {},
      pagination: { page: 1, limit: 20, total: 0 },

      fetchProjects: async (params) => {
        set({ loading: true, error: null });

        try {
          const response = await projectApi.getProjects({
            ...get().filters,
            ...get().pagination,
            ...params,
          });

          set({
            projects: response.data.projects,
            pagination: response.data.pagination,
            loading: false,
          });
        } catch (error) {
          set({
            error: error.message,
            loading: false,
          });
        }
      },

      fetchProject: async (id) => {
        set({ loading: true, error: null });

        try {
          const response = await projectApi.getProject(id);
          set({
            currentProject: response.data,
            loading: false,
          });
        } catch (error) {
          set({
            error: error.message,
            loading: false,
          });
        }
      },

      createProject: async (project) => {
        try {
          const response = await projectApi.createProject(project);
          const newProject = response.data;

          set((state) => ({
            projects: [newProject, ...state.projects],
          }));

          return newProject;
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      updateProject: async (id, project) => {
        try {
          const response = await projectApi.updateProject(id, project);
          const updatedProject = response.data;

          set((state) => ({
            projects: state.projects.map((p) =>
              p.id === id ? updatedProject : p
            ),
            currentProject:
              state.currentProject?.id === id
                ? updatedProject
                : state.currentProject,
          }));

          return updatedProject;
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      deleteProject: async (id) => {
        try {
          await projectApi.deleteProject(id);

          set((state) => ({
            projects: state.projects.filter((p) => p.id !== id),
            currentProject:
              state.currentProject?.id === id ? null : state.currentProject,
          }));
        } catch (error) {
          set({ error: error.message });
          throw error;
        }
      },

      setFilters: (filters) => {
        set((state) => ({
          filters: { ...state.filters, ...filters },
        }));
      },

      setPagination: (pagination) => {
        set((state) => ({
          pagination: { ...state.pagination, ...pagination },
        }));
      },
    }),
    { name: 'project-store' }
  )
);
```

### å®æ—¶åä½œå®ç°
```typescript
// ä½¿ç”¨YJSå®ç°å®æ—¶åä½œ
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import { BlockNoteEditor } from '@blocknote/core';

// åä½œæ–‡æ¡£ç®¡ç†
class CollaborationManager {
  private doc: Y.Doc;
  private provider: WebsocketProvider;
  private editor: BlockNoteEditor | null = null;

  constructor(projectId: string, documentId: string) {
    // åˆå§‹åŒ–YJSæ–‡æ¡£
    this.doc = new Y.Doc();

    // è¿æ¥åˆ°WebSocketæœåŠ¡å™¨
    this.provider = new WebsocketProvider(
      `ws://localhost:1234`,
      `${projectId}-${documentId}`,
      this.doc
    );

    // è®¾ç½®åä½œäº‹ä»¶ç›‘å¬
    this.setupEventListeners();
  }

  private setupEventListeners() {
    // ç”¨æˆ·è¿æ¥/æ–­å¼€äº‹ä»¶
    this.provider.awareness.on('change', () => {
      const users = this.provider.awareness.getStates();
      this.updateUserList(users);
    });

    // åŒæ­¥çŠ¶æ€äº‹ä»¶
    this.provider.on('sync', (synced: boolean) => {
      if (synced) {
        console.log('Document synchronized');
      }
    });

    // è¿æ¥çŠ¶æ€äº‹ä»¶
    this.provider.on('status', (status: 'connected' | 'disconnected') => {
      console.log('Connection status:', status);
    });
  }

  // åˆå§‹åŒ–ç¼–è¾‘å™¨
  initializeEditor(container: HTMLElement) {
    // è·å–å…±äº«çš„YJSæ–‡æœ¬
    const yText = this.doc.getText('content');

    // åˆ›å»ºBlockNoteç¼–è¾‘å™¨
    this.editor = new BlockNoteEditor({
      element: container,
      onTextChange: () => {
        // ç¼–è¾‘å™¨å†…å®¹å˜åŒ–æ—¶åŒæ­¥åˆ°YJS
        const content = this.editor?.getContent();
        if (content) {
          yText.insert(0, JSON.stringify(content));
        }
      },
    });

    // ç›‘å¬YJSæ–‡æœ¬å˜åŒ–
    yText.observe(() => {
      const content = yText.toString();
      if (content && this.editor) {
        this.editor.setContent(JSON.parse(content));
      }
    });

    return this.editor;
  }

  // æ·»åŠ è¯„è®º
  addComment(position: number, text: string, userId: string) {
    const comments = this.doc.getMap('comments');
    const commentId = Date.now().toString();

    comments.set(commentId, {
      id: commentId,
      position,
      text,
      userId,
      timestamp: new Date().toISOString(),
      replies: [],
    });
  }

  // å¤„ç†ç”¨æˆ·å…‰æ ‡ä½ç½®
  updateCursorPosition(userId: string, position: number) {
    this.provider.awareness.setLocalStateField('cursor', {
      userId,
      position,
      timestamp: Date.now(),
    });
  }

  // è·å–åœ¨çº¿ç”¨æˆ·åˆ—è¡¨
  getOnlineUsers() {
    const users = this.provider.awareness.getStates();
    return Array.from(users.entries()).map(([userId, state]) => ({
      userId,
      name: state.name,
      cursor: state.cursor,
      color: state.color,
    }));
  }

  // é”€æ¯åä½œç®¡ç†å™¨
  destroy() {
    this.editor?.destroy();
    this.provider.destroy();
    this.doc.destroy();
  }

  private updateUserList(users: Map<number, any>) {
    // æ›´æ–°UIä¸­çš„ç”¨æˆ·åˆ—è¡¨
    const onlineUsers = Array.from(users.entries()).map(([userId, state]) => ({
      userId,
      name: state.name,
      color: state.color,
    }));

    // è§¦å‘ç”¨æˆ·åˆ—è¡¨æ›´æ–°äº‹ä»¶
    this.onUserListChange?.(onlineUsers);
  }

  public onUserListChange?: (users: any[]) => void;
}

// React Hookå°è£…
export const useCollaboration = (projectId: string, documentId: string) => {
  const [collaborationManager, setCollaborationManager] = useState<CollaborationManager | null>(null);
  const [onlineUsers, setOnlineUsers] = useState<any[]>([]);

  useEffect(() => {
    const manager = new CollaborationManager(projectId, documentId);

    manager.onUserListChange = (users) => {
      setOnlineUsers(users);
    };

    setCollaborationManager(manager);

    return () => {
      manager.destroy();
    };
  }, [projectId, documentId]);

  return {
    collaborationManager,
    onlineUsers,
  };
};
```

## âš™ï¸ åç«¯æœåŠ¡è¯¦ç»†å®ç°

### å¾®æœåŠ¡æ¶æ„å®ç°
```python
# ç”¨æˆ·æœåŠ¡å®ç°
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from typing import List, Optional
import redis
import jwt
from datetime import datetime, timedelta

app = FastAPI(title="User Service", version="1.0.0")

# ä¾èµ–æ³¨å…¥
security = HTTPBearer()
redis_client = redis.Redis(host='redis', port=6379, db=0)

# æ•°æ®åº“æ¨¡å‹
from sqlalchemy import Column, String, DateTime, Boolean, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.postgresql import UUID
import uuid

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(100), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    full_name = Column(String(100))
    company_id = Column(UUID(as_uuid=True), nullable=True)
    role = Column(String(20), nullable=False, default='user')
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    # ä¸ªäººèµ„æ–™
    avatar_url = Column(String(500))
    phone = Column(String(20))
    department = Column(String(100))
    position = Column(String(100))
    bio = Column(Text)

# Pydanticæ¨¡å‹
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None
    company_id: Optional[str] = None
    role: str = 'user'

class UserCreate(UserBase):
    password: str

    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        return v

class UserUpdate(BaseModel):
    full_name: Optional[str] = None
    avatar_url: Optional[str] = None
    phone: Optional[str] = None
    department: Optional[str] = None
    position: Optional[str] = None
    bio: Optional[str] = None

class UserResponse(UserBase):
    id: str
    is_active: bool
    is_verified: bool
    created_at: datetime
    last_login: Optional[datetime] = None

    class Config:
        orm_mode = True

class LoginRequest(BaseModel):
    username: str
    password: str

class LoginResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = 'bearer'
    expires_in: int
    user: UserResponse

# æ•°æ®åº“ä¾èµ–
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# è®¤è¯ä¾èµ–
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    try:
        payload = jwt.decode(
            credentials.credentials,
            SECRET_KEY,
            algorithms=[ALGORITHM]
        )
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )

    return user

# ç”¨æˆ·æ³¨å†Œ
@app.post("/register", response_model=UserResponse)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    # æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    existing_user = db.query(User).filter(
        (User.username == user_data.username) | (User.email == user_data.email)
    ).first()

    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username or email already registered"
        )

    # åˆ›å»ºæ–°ç”¨æˆ·
    hashed_password = hash_password(user_data.password)
    db_user = User(
        username=user_data.username,
        email=user_data.email,
        password_hash=hashed_password,
        full_name=user_data.full_name,
        company_id=user_data.company_id,
        role=user_data.role
    )

    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    # å‘é€éªŒè¯é‚®ä»¶
    await send_verification_email(db_user.email)

    return db_user

# ç”¨æˆ·ç™»å½•
@app.post("/login", response_model=LoginResponse)
async def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    # éªŒè¯ç”¨æˆ·å‡­æ®
    user = authenticate_user(db, login_data.username, login_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )

    # ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)}, expires_delta=access_token_expires
    )

    # ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
    refresh_token_expires = timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    refresh_token = create_refresh_token(
        data={"sub": str(user.id)}, expires_delta=refresh_token_expires
    )

    # æ›´æ–°æœ€åç™»å½•æ—¶é—´
    user.last_login = datetime.utcnow()
    db.commit()

    # ç¼“å­˜ç”¨æˆ·ä¿¡æ¯
    cache_user_info(user.id, user)

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        "user": user
    }

# è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
@app.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    return current_user

# æ›´æ–°ç”¨æˆ·ä¿¡æ¯
@app.put("/me", response_model=UserResponse)
async def update_user_info(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    for field, value in user_update.dict(exclude_unset=True).items():
        setattr(current_user, field, value)

    current_user.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(current_user)

    # æ›´æ–°ç¼“å­˜
    cache_user_info(current_user.id, current_user)

    return current_user

# åˆ·æ–°ä»¤ç‰Œ
@app.post("/refresh")
async def refresh_token(refresh_token: str, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(refresh_token, REFRESH_SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token"
            )
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )

    user = db.query(User).filter(User.id == user_id).first()
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive"
        )

    # ç”Ÿæˆæ–°çš„è®¿é—®ä»¤ç‰Œ
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)}, expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
    }

# å·¥å…·å‡½æ•°
import bcrypt
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = db.query(User).filter(
        (User.username == username) | (User.email == username)
    ).first()

    if not user or not verify_password(password, user.password_hash):
        return None

    return user

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(days=7)

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, REFRESH_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def cache_user_info(user_id: str, user: User):
    user_data = {
        "id": str(user.id),
        "username": user.username,
        "email": user.email,
        "full_name": user.full_name,
        "role": user.role,
        "company_id": str(user.company_id) if user.company_id else None,
        "is_active": user.is_active,
        "is_verified": user.is_verified,
    }

    redis_client.setex(
        f"user:{user_id}",
        3600,  # 1å°æ—¶è¿‡æœŸ
        json.dumps(user_data)
    )

async def send_verification_email(email: str):
    # å®ç°é‚®ä»¶å‘é€é€»è¾‘
    pass

# é…ç½®å¸¸é‡
SECRET_KEY = "your-secret-key"
REFRESH_SECRET_KEY = "your-refresh-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7
```

### AIæœåŠ¡è¯¦ç»†å®ç°
```python
# AIæœåŠ¡å®ç°
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import openai
import langchain
from langchain.chat_models import ChatOpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Pinecone
import pinecone
import asyncio
from concurrent.futures import ThreadPoolExecutor
import hashlib

app = FastAPI(title="AI Service", version="1.0.0")

# é…ç½®
OPENAI_API_KEY = "your-openai-api-key"
PINECONE_API_KEY = "your-pinecone-api-key"
PINECONE_ENVIRONMENT = "your-pinecone-environment"

# åˆå§‹åŒ–å®¢æˆ·ç«¯
openai.api_key = OPENAI_API_KEY
pinecone.init(api_key=PINECONE_API_KEY, environment=PINECONE_ENVIRONMENT)

# çº¿ç¨‹æ± 
executor = ThreadPoolExecutor(max_workers=10)

# æ•°æ®æ¨¡å‹
class DocumentAnalysisRequest(BaseModel):
    document_id: str
    document_content: str
    document_type: str  # 'tender', 'proposal', 'contract'
    analysis_options: List[str] = ['requirements', 'risks', 'opportunities']

class ContentGenerationRequest(BaseModel):
    project_id: str
    template_id: str
    requirements: Dict[str, Any]
    company_profile: Dict[str, Any]
    generation_options: Dict[str, Any] = {}

class MatchingAnalysisRequest(BaseModel):
    project_id: str
    requirements: List[str]
    company_capabilities: Dict[str, Any]
    matching_criteria: List[str] = ['technical', 'experience', 'resources']

class DocumentAnalysisResponse(BaseModel):
    document_id: str
    analysis_results: Dict[str, Any]
    confidence_score: float
    processing_time: float

class ContentGenerationResponse(BaseModel):
    generated_content: Dict[str, Any]
    quality_score: float
    suggestions: List[str]
    processing_time: float

# æ‹›æ ‡æ–‡æ¡£åˆ†æ
class TenderDocumentAnalyzer:
    def __init__(self):
        self.llm = ChatOpenAI(temperature=0.1, model_name="gpt-4")
        self.embeddings = OpenAIEmbeddings()

        # åˆå§‹åŒ–æç¤ºæ¨¡æ¿
        self.requirements_prompt = PromptTemplate(
            input_variables=["document_content"],
            template="""
            ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æ‹›æ ‡æ–‡ä»¶åˆ†æä¸“å®¶ã€‚è¯·ä»”ç»†åˆ†æä»¥ä¸‹æ‹›æ ‡æ–‡ä»¶å†…å®¹ï¼Œæå–å…³é”®ä¿¡æ¯ï¼š

            æ‹›æ ‡æ–‡ä»¶å†…å®¹ï¼š
            {document_content}

            è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºåˆ†æç»“æœï¼š
            1. é¡¹ç›®åŸºæœ¬ä¿¡æ¯
            2. æŠ€æœ¯è¦æ±‚
            3. å•†åŠ¡æ¡æ¬¾
            4. è¯„åˆ†æ ‡å‡†
            5. é£é™©å› ç´ 
            6. æŠ•æ ‡å»ºè®®

            è¯·ç¡®ä¿åˆ†æç»“æœå‡†ç¡®ã€å®Œæ•´ã€æœ‰ä»·å€¼ã€‚
            """
        )

        self.risk_analysis_prompt = PromptTemplate(
            input_variables=["document_content"],
            template="""
            è¯·åˆ†æä»¥ä¸‹æ‹›æ ‡æ–‡ä»¶ä¸­çš„æ½œåœ¨é£é™©ï¼š

            æ‹›æ ‡æ–‡ä»¶å†…å®¹ï¼š
            {document_content}

            è¯·è¯†åˆ«å¹¶åˆ†ç±»ä»¥ä¸‹é£é™©ï¼š
            1. æŠ€æœ¯é£é™©
            2. å•†åŠ¡é£é™©
            3. åˆè§„é£é™©
            4. æ—¶é—´é£é™©
            5. æˆæœ¬é£é™©

            å¯¹æ¯ä¸ªé£é™©ï¼Œè¯·æä¾›ï¼š
            - é£é™©æè¿°
            - å½±å“ç¨‹åº¦ï¼ˆé«˜/ä¸­/ä½ï¼‰
            - å‘ç”Ÿæ¦‚ç‡ï¼ˆé«˜/ä¸­/ä½ï¼‰
            - åº”å¯¹å»ºè®®
            """
        )

    async def analyze_document(self, request: DocumentAnalysisRequest) -> DocumentAnalysisResponse:
        start_time = time.time()

        try:
            # å¹¶è¡Œæ‰§è¡Œå¤šä¸ªåˆ†æä»»åŠ¡
            tasks = []

            if 'requirements' in request.analysis_options:
                tasks.append(self._extract_requirements(request.document_content))

            if 'risks' in request.analysis_options:
                tasks.append(self._analyze_risks(request.document_content))

            if 'opportunities' in request.analysis_options:
                tasks.append(self._identify_opportunities(request.document_content))

            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            results = await asyncio.gather(*tasks)

            # åˆå¹¶åˆ†æç»“æœ
            analysis_results = {
                "document_id": request.document_id,
                "document_type": request.document_type,
                "analysis_timestamp": datetime.utcnow().isoformat(),
            }

            for i, option in enumerate(request.analysis_options):
                analysis_results[option] = results[i]

            # è®¡ç®—ç½®ä¿¡åº¦åˆ†æ•°
            confidence_score = self._calculate_confidence_score(analysis_results)

            processing_time = time.time() - start_time

            return DocumentAnalysisResponse(
                document_id=request.document_id,
                analysis_results=analysis_results,
                confidence_score=confidence_score,
                processing_time=processing_time
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

    async def _extract_requirements(self, content: str) -> Dict[str, Any]:
        """æå–æ‹›æ ‡è¦æ±‚"""
        chain = LLMChain(llm=self.llm, prompt=self.requirements_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            {"document_content": content[:4000]}  # é™åˆ¶å†…å®¹é•¿åº¦
        )

        return {
            "requirements_analysis": result,
            "extracted_date": datetime.utcnow().isoformat()
        }

    async def _analyze_risks(self, content: str) -> Dict[str, Any]:
        """åˆ†æé£é™©å› ç´ """
        chain = LLMChain(llm=self.llm, prompt=self.risk_analysis_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            {"document_content": content[:4000]}
        )

        return {
            "risk_analysis": result,
            "analysis_date": datetime.utcnow().isoformat()
        }

    async def _identify_opportunities(self, content: str) -> Dict[str, Any]:
        """è¯†åˆ«å•†ä¸šæœºä¼š"""
        opportunity_prompt = PromptTemplate(
            input_variables=["document_content"],
            template="""
            è¯·åˆ†æä»¥ä¸‹æ‹›æ ‡æ–‡ä»¶ä¸­çš„å•†ä¸šæœºä¼šï¼š

            æ‹›æ ‡æ–‡ä»¶å†…å®¹ï¼š
            {document_content}

            è¯·è¯†åˆ«ï¼š
            1. å¸‚åœºæœºä¼š
            2. æŠ€æœ¯åˆ›æ–°æœºä¼š
            3. åˆä½œæœºä¼š
            4. é•¿æœŸåˆä½œå¯èƒ½æ€§
            5. å·®å¼‚åŒ–ç«äº‰æœºä¼š

            å¯¹æ¯ä¸ªæœºä¼šï¼Œè¯·æä¾›ï¼š
            - æœºä¼šæè¿°
            - æ½œåœ¨ä»·å€¼
            - å®ç°éš¾åº¦
            - å»ºè®®ç­–ç•¥
            """
        )

        chain = LLMChain(llm=self.llm, prompt=opportunity_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            {"document_content": content[:4000]}
        )

        return {
            "opportunity_analysis": result,
            "analysis_date": datetime.utcnow().isoformat()
        }

    def _calculate_confidence_score(self, results: Dict[str, Any]) -> float:
        """è®¡ç®—åˆ†æç»“æœçš„ç½®ä¿¡åº¦åˆ†æ•°"""
        # åŸºäºå¤šä¸ªå› ç´ è®¡ç®—ç½®ä¿¡åº¦
        factors = {
            "completeness": len(results) / 3.0,  # å‡è®¾æœ€å¤š3ä¸ªåˆ†æç»´åº¦
            "content_length": sum(len(str(v)) for v in results.values()) / 1000.0,
            "structure_quality": 0.8  # åŸºäºç»“æœç»“æ„çš„è´¨é‡è¯„åˆ†
        }

        # åŠ æƒå¹³å‡
        weights = {"completeness": 0.4, "content_length": 0.3, "structure_quality": 0.3}

        confidence_score = sum(
            factors[factor] * weights[factor]
            for factor in factors
        )

        return min(max(confidence_score, 0.0), 1.0)

# å†…å®¹ç”Ÿæˆå™¨
class ContentGenerator:
    def __init__(self):
        self.llm = ChatOpenAI(temperature=0.3, model_name="gpt-4")

        # åˆå§‹åŒ–å„ç§å†…å®¹ç”Ÿæˆçš„æç¤ºæ¨¡æ¿
        self.executive_summary_prompt = PromptTemplate(
            input_variables=["requirements", "company_profile", "project_info"],
            template="""
            åŸºäºä»¥ä¸‹ä¿¡æ¯ç”Ÿæˆä¸€ä»½ä¼˜ç§€çš„æ‰§è¡Œæ‘˜è¦ï¼š

            é¡¹ç›®è¦æ±‚ï¼š
            {requirements}

            å…¬å¸ä¿¡æ¯ï¼š
            {company_profile}

            é¡¹ç›®ä¿¡æ¯ï¼š
            {project_info}

            è¯·ç”Ÿæˆä¸€ä»½ä¸“ä¸šã€æœ‰è¯´æœåŠ›çš„æ‰§è¡Œæ‘˜è¦ï¼ŒåŒ…æ‹¬ï¼š
            1. é¡¹ç›®ç†è§£
            2. è§£å†³æ–¹æ¡ˆæ¦‚è¿°
            3. å…¬å¸ä¼˜åŠ¿
            4. ä»·å€¼ä¸»å¼ 
            5. æˆåŠŸä¿è¯

            è¦æ±‚ï¼š
            - è¯­è¨€ä¸“ä¸šã€ç®€æ´
            - çªå‡ºæ ¸å¿ƒç«äº‰åŠ›
            - ä½“ç°å®¢æˆ·ä»·å€¼
            - é•¿åº¦æ§åˆ¶åœ¨500-800å­—
            """
        )

        self.technical_proposal_prompt = PromptTemplate(
            input_variables=["requirements", "company_capabilities", "technical_approach"],
            template="""
            åŸºäºä»¥ä¸‹ä¿¡æ¯ç”ŸæˆæŠ€æœ¯æ–¹æ¡ˆï¼š

            æŠ€æœ¯è¦æ±‚ï¼š
            {requirements}

            å…¬å¸æŠ€æœ¯èƒ½åŠ›ï¼š
            {company_capabilities}

            æŠ€æœ¯è·¯çº¿ï¼š
            {technical_approach}

            è¯·ç”Ÿæˆè¯¦ç»†çš„æŠ€æœ¯æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š
            1. æŠ€æœ¯æ¶æ„è®¾è®¡
            2. å®æ–½æ–¹æ³•è®º
            3. å…³é”®æŠ€æœ¯ç‚¹
            4. è´¨é‡ä¿è¯æªæ–½
            5. é£é™©æ§åˆ¶æ–¹æ¡ˆ
            6. åˆ›æ–°äº®ç‚¹

            è¦æ±‚ï¼š
            - æŠ€æœ¯æ–¹æ¡ˆè¦å…·ä½“å¯è¡Œ
            - ä½“ç°å…¬å¸æŠ€æœ¯ä¼˜åŠ¿
            - è§£å†³å®¢æˆ·æ ¸å¿ƒå…³åˆ‡
            - å…·æœ‰å¯æ“ä½œæ€§
            """
        )

    async def generate_content(self, request: ContentGenerationRequest) -> ContentGenerationResponse:
        """ç”Ÿæˆæ ‡ä¹¦å†…å®¹"""
        start_time = time.time()

        try:
            # å‡†å¤‡ç”Ÿæˆå‚æ•°
            generation_params = {
                "requirements": request.requirements,
                "company_profile": request.company_profile,
                "project_info": request.generation_options.get("project_info", {}),
                "company_capabilities": request.company_profile.get("capabilities", {}),
                "technical_approach": request.generation_options.get("technical_approach", "")
            }

            # å¹¶è¡Œç”Ÿæˆå„ä¸ªç« èŠ‚
            tasks = [
                self._generate_executive_summary(generation_params),
                self._generate_technical_proposal(generation_params),
                self._generate_management_approach(generation_params),
                self._generate_pricing_proposal(generation_params)
            ]

            results = await asyncio.gather(*tasks)

            # ç»„è£…ç”Ÿæˆçš„å†…å®¹
            generated_content = {
                "executive_summary": results[0],
                "technical_proposal": results[1],
                "management_approach": results[2],
                "pricing_proposal": results[3],
                "generation_metadata": {
                    "project_id": request.project_id,
                    "template_id": request.template_id,
                    "generation_timestamp": datetime.utcnow().isoformat(),
                    "generation_options": request.generation_options
                }
            }

            # è´¨é‡è¯„ä¼°
            quality_score = await self._assess_content_quality(generated_content)

            # ç”Ÿæˆæ”¹è¿›å»ºè®®
            suggestions = await self._generate_improvement_suggestions(generated_content, quality_score)

            processing_time = time.time() - start_time

            return ContentGenerationResponse(
                generated_content=generated_content,
                quality_score=quality_score,
                suggestions=suggestions,
                processing_time=processing_time
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Content generation failed: {str(e)}")

    async def _generate_executive_summary(self, params: Dict[str, Any]) -> str:
        """ç”Ÿæˆæ‰§è¡Œæ‘˜è¦"""
        chain = LLMChain(llm=self.llm, prompt=self.executive_summary_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            params
        )

        return result

    async def _generate_technical_proposal(self, params: Dict[str, Any]) -> str:
        """ç”ŸæˆæŠ€æœ¯æ–¹æ¡ˆ"""
        chain = LLMChain(llm=self.llm, prompt=self.technical_proposal_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            params
        )

        return result

    async def _generate_management_approach(self, params: Dict[str, Any]) -> str:
        """ç”Ÿæˆç®¡ç†æ–¹æ¡ˆ"""
        management_prompt = PromptTemplate(
            input_variables=["company_profile", "project_info"],
            template="""
            åŸºäºä»¥ä¸‹ä¿¡æ¯ç”Ÿæˆé¡¹ç›®ç®¡ç†æ–¹æ¡ˆï¼š

            å…¬å¸ç®¡ç†èƒ½åŠ›ï¼š
            {company_profile}

            é¡¹ç›®ä¿¡æ¯ï¼š
            {project_info}

            è¯·ç”Ÿæˆè¯¦ç»†çš„é¡¹ç›®ç®¡ç†æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š
            1. é¡¹ç›®ç»„ç»‡æ¶æ„
            2. å›¢é˜Ÿé…ç½®
            3. æ²Ÿé€šæœºåˆ¶
            4. è¿›åº¦ç®¡ç†
            5. è´¨é‡ç®¡ç†
            6. é£é™©ç®¡ç†
            """
        )

        chain = LLMChain(llm=self.llm, prompt=management_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            params
        )

        return result

    async def _generate_pricing_proposal(self, params: Dict[str, Any]) -> str:
        """ç”Ÿæˆå•†åŠ¡æŠ¥ä»·æ–¹æ¡ˆ"""
        pricing_prompt = PromptTemplate(
            input_variables=["requirements", "company_profile"],
            template="""
            åŸºäºä»¥ä¸‹ä¿¡æ¯ç”Ÿæˆå•†åŠ¡æŠ¥ä»·æ–¹æ¡ˆï¼š

            é¡¹ç›®è¦æ±‚ï¼š
            {requirements}

            å…¬å¸å®šä»·ç­–ç•¥ï¼š
            {company_profile}

            è¯·ç”Ÿæˆåˆç†çš„å•†åŠ¡æŠ¥ä»·æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š
            1. æŠ¥ä»·æ€»è§ˆ
            2. åˆ†é¡¹æŠ¥ä»·
            3. æŠ¥ä»·è¯´æ˜
            4. ä»˜æ¬¾æ–¹å¼
            5. æœåŠ¡æ‰¿è¯º
            6. ä»·å€¼è¯´æ˜
            """
        )

        chain = LLMChain(llm=self.llm, prompt=pricing_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            params
        )

        return result

    async def _assess_content_quality(self, content: Dict[str, Any]) -> float:
        """è¯„ä¼°å†…å®¹è´¨é‡"""
        quality_prompt = PromptTemplate(
            input_variables=["content"],
            template="""
            è¯·è¯„ä¼°ä»¥ä¸‹æ ‡ä¹¦å†…å®¹çš„è´¨é‡ï¼š

            å†…å®¹ï¼š
            {content}

            è¯·ä»ä»¥ä¸‹ç»´åº¦è¯„ä¼°ï¼ˆ0-100åˆ†ï¼‰ï¼š
            1. å®Œæ•´æ€§
            2. ä¸“ä¸šæ€§
            3. é’ˆå¯¹æ€§
            4. è¯´æœåŠ›
            5. é€»è¾‘æ€§

            è¯·ç»™å‡ºæ€»åˆ†å’Œæ”¹è¿›å»ºè®®ã€‚
            """
        )

        chain = LLMChain(llm=ChatOpenAI(temperature=0.1), prompt=quality_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            {"content": str(content)}
        )

        # ä»ç»“æœä¸­æå–åˆ†æ•°
        try:
            score = float(result.split("æ€»åˆ†ï¼š")[1].split("åˆ†")[0])
            return min(max(score / 100.0, 0.0), 1.0)
        except:
            return 0.7  # é»˜è®¤åˆ†æ•°

    async def _generate_improvement_suggestions(self, content: Dict[str, Any], quality_score: float) -> List[str]:
        """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
        if quality_score > 0.8:
            return ["å†…å®¹è´¨é‡ä¼˜ç§€ï¼Œå»ºè®®ä¿æŒ"]

        improvement_prompt = PromptTemplate(
            input_variables=["content", "quality_score"],
            template="""
            åŸºäºå½“å‰è´¨é‡åˆ†æ•°ï¼š{quality_score}

            è¯·ä¸ºä»¥ä¸‹æ ‡ä¹¦å†…å®¹æä¾›å…·ä½“çš„æ”¹è¿›å»ºè®®ï¼š

            å†…å®¹ï¼š
            {content}

            è¯·æä¾›3-5æ¡å…·ä½“ã€å¯æ“ä½œçš„æ”¹è¿›å»ºè®®ã€‚
            """
        )

        chain = LLMChain(llm=ChatOpenAI(temperature=0.2), prompt=improvement_prompt)

        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            executor,
            chain.run,
            {"content": str(content), "quality_score": quality_score}
        )

        # è§£æå»ºè®®åˆ—è¡¨
        suggestions = [s.strip() for s in result.split('\n') if s.strip()]
        return suggestions[:5]  # æœ€å¤šè¿”å›5æ¡å»ºè®®

# åˆå§‹åŒ–æœåŠ¡
tender_analyzer = TenderDocumentAnalyzer()
content_generator = ContentGenerator()

# APIç«¯ç‚¹
@app.post("/analyze/document", response_model=DocumentAnalysisResponse)
async def analyze_document(request: DocumentAnalysisRequest):
    return await tender_analyzer.analyze_document(request)

@app.post("/generate/content", response_model=ContentGenerationResponse)
async def generate_content(request: ContentGenerationRequest):
    return await content_generator.generate_content(request)

# å¥åº·æ£€æŸ¥
@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "ai-service"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8005)
```

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡è¯¦ç»†å®ç°

### æ•°æ®åº“æ¶æ„è®¾è®¡
```sql
-- æ•°æ®åº“æ¶æ„è¯¦ç»†è®¾è®¡
-- åˆ›å»ºæ•°æ®åº“
CREATE DATABASE aibidcomposer;
CREATE DATABASE aibidcomposer_test;
CREATE DATABASE aibidcomposer_dev;

-- ä½¿ç”¨ä¸»æ•°æ®åº“
\c aibidcomposer;

-- åˆ›å»ºæ‰©å±•
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- å¯ç”¨è¡Œçº§å®‰å…¨
ALTER DATABASE aibidcomposer SET row_security = on;

-- ä¼ä¸šä¿¡æ¯è¡¨
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(200) NOT NULL,
    display_name VARCHAR(200),
    description TEXT,
    industry VARCHAR(100),
    company_size VARCHAR(50), -- 'startup', 'small', 'medium', 'large', 'enterprise'
    website VARCHAR(500),
    logo_url VARCHAR(500),
    contact_email VARCHAR(200),
    contact_phone VARCHAR(50),
    address TEXT,
    country VARCHAR(100),
    region VARCHAR(100),
    city VARCHAR(100),
    postal_code VARCHAR(20),

    -- ä¸šåŠ¡ä¿¡æ¯
    established_year INTEGER,
    annual_revenue DECIMAL(15,2),
    employee_count INTEGER,

    -- ç³»ç»Ÿå­—æ®µ
    subscription_tier VARCHAR(20) DEFAULT 'basic', -- 'basic', 'professional', 'enterprise', 'flagship'
    subscription_status VARCHAR(20) DEFAULT 'active', -- 'active', 'inactive', 'suspended', 'cancelled'
    subscription_expires_at TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,

    -- å®¡è®¡å­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID,
    updated_by UUID,

    -- çº¦æŸ
    CONSTRAINT companies_name_unique UNIQUE (name),
    CONSTRAINT companies_email_check CHECK (contact_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT companies_phone_check CHECK (contact_phone ~* '^[+]?[\d\s\-()]+$'),
    CONSTRAINT companies_size_check CHECK (company_size IN ('startup', 'small', 'medium', 'large', 'enterprise')),
    CONSTRAINT companies_tier_check CHECK (subscription_tier IN ('basic', 'professional', 'enterprise', 'flagship'))
);

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,

    -- åŸºæœ¬ä¿¡æ¯
    username VARCHAR(50) NOT NULL,
    email VARCHAR(200) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    first_name VARCHAR(50),
    last_name VARCHAR(50),

    -- ä¸ªäººèµ„æ–™
    avatar_url VARCHAR(500),
    phone VARCHAR(20),
    department VARCHAR(100),
    position VARCHAR(100),
    bio TEXT,
    expertise TEXT[], -- ä¸“ä¸šæŠ€èƒ½æ•°ç»„
    languages JSONB, -- è¯­è¨€èƒ½åŠ›

    -- è§’è‰²å’Œæƒé™
    role VARCHAR(20) NOT NULL DEFAULT 'user',
    permissions JSONB DEFAULT '[]', -- æƒé™åˆ—è¡¨

    -- çŠ¶æ€
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    is_online BOOLEAN DEFAULT false,
    last_login_at TIMESTAMP,
    login_count INTEGER DEFAULT 0,

    -- åå¥½è®¾ç½®
    timezone VARCHAR(50) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'zh-CN',
    theme VARCHAR(20) DEFAULT 'light', -- 'light', 'dark', 'auto'
    notification_settings JSONB DEFAULT '{}',

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID,
    updated_by UUID,

    -- çº¦æŸ
    CONSTRAINT users_username_unique UNIQUE (username),
    CONSTRAINT users_email_unique UNIQUE (email),
    CONSTRAINT users_email_check CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    CONSTRAINT users_phone_check CHECK (phone ~* '^[+]?[\d\s\-()]+$'),
    CONSTRAINT users_role_check CHECK (role IN ('super_admin', 'admin', 'manager', 'editor', 'viewer', 'user')),
    CONSTRAINT users_theme_check CHECK (theme IN ('light', 'dark', 'auto'))
);

-- é¡¹ç›®è¡¨
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    created_by UUID NOT NULL REFERENCES users(id),

    -- åŸºæœ¬ä¿¡æ¯
    name VARCHAR(200) NOT NULL,
    description TEXT,
    project_number VARCHAR(100), -- é¡¹ç›®ç¼–å·
    client_name VARCHAR(200),
    client_industry VARCHAR(100),
    project_type VARCHAR(50), -- 'government', 'commercial', 'internal'
    project_category VARCHAR(100), -- 'construction', 'it', 'consulting', 'manufacturing'

    -- æ‹›æ ‡ä¿¡æ¯
    tender_document_url VARCHAR(500),
    tender_document_id UUID, -- å…³è”åˆ°æ–‡æ¡£è¡¨
    submission_deadline TIMESTAMP,
    bid_opening_date TIMESTAMP,
    budget_amount DECIMAL(15,2),
    budget_currency VARCHAR(10) DEFAULT 'CNY',

    -- é¡¹ç›®çŠ¶æ€
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    -- 'draft', 'in_progress', 'review', 'approved', 'submitted', 'won', 'lost', 'cancelled'
    priority VARCHAR(20) DEFAULT 'medium', -- 'low', 'medium', 'high', 'urgent'

    -- é¡¹ç›®ä¿¡æ¯
    estimated_duration INTEGER, -- é¢„ä¼°å¤©æ•°
    actual_duration INTEGER, -- å®é™…å¤©æ•°
    team_size INTEGER,

    -- ç«äº‰ä¿¡æ¯
    competitors JSONB DEFAULT '[]',
    market_analysis JSONB,

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    submitted_at TIMESTAMP,
    completed_at TIMESTAMP,

    -- çº¦æŸ
    CONSTRAINT projects_status_check CHECK (status IN ('draft', 'in_progress', 'review', 'approved', 'submitted', 'won', 'lost', 'cancelled')),
    CONSTRAINT projects_priority_check CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
    CONSTRAINT projects_type_check CHECK (project_type IN ('government', 'commercial', 'internal'))
);

-- é¡¹ç›®æˆå‘˜è¡¨
CREATE TABLE project_members (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- è§’è‰²ä¿¡æ¯
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- 'owner', 'manager', 'editor', 'reviewer', 'member'
    responsibilities TEXT[],

    -- æƒé™
    can_edit BOOLEAN DEFAULT false,
    can_delete BOOLEAN DEFAULT false,
    can_invite BOOLEAN DEFAULT false,
    can_approve BOOLEAN DEFAULT false,

    -- çŠ¶æ€
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'inactive', 'pending'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMP,

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by UUID REFERENCES users(id),

    -- çº¦æŸ
    CONSTRAINT project_members_unique UNIQUE (project_id, user_id),
    CONSTRAINT project_members_role_check CHECK (role IN ('owner', 'manager', 'editor', 'reviewer', 'member')),
    CONSTRAINT project_members_status_check CHECK (status IN ('active', 'inactive', 'pending'))
);

-- æ¨¡æ¿è¡¨
CREATE TABLE templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE, -- NULLè¡¨ç¤ºå…¬å…±æ¨¡æ¿
    created_by UUID NOT NULL REFERENCES users(id),

    -- åŸºæœ¬ä¿¡æ¯
    name VARCHAR(200) NOT NULL,
    description TEXT,
    category VARCHAR(50) NOT NULL, -- 'tender', 'proposal', 'contract', 'report'
    industry VARCHAR(100), -- é€‚ç”¨è¡Œä¸š
    project_type VARCHAR(50), -- é€‚ç”¨é¡¹ç›®ç±»å‹

    -- æ¨¡æ¿å†…å®¹
    content JSONB NOT NULL, -- æ¨¡æ¿å†…å®¹ç»“æ„
    structure JSONB, -- æ¨¡æ¿ç»“æ„å®šä¹‰
    variables JSONB DEFAULT '{}', -- æ¨¡æ¿å˜é‡å®šä¹‰
    sections JSONB DEFAULT '[]', -- ç« èŠ‚å®šä¹‰

    -- æ¨¡æ¿å±æ€§
    is_public BOOLEAN DEFAULT false, -- æ˜¯å¦å…¬å¼€
    is_active BOOLEAN DEFAULT true,
    is_default BOOLEAN DEFAULT false, -- æ˜¯å¦ä¸ºé»˜è®¤æ¨¡æ¿

    -- ä½¿ç”¨ç»Ÿè®¡
    usage_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2) DEFAULT 0.00, -- å¹³å‡è¯„åˆ†
    rating_count INTEGER DEFAULT 0,

    -- ç‰ˆæœ¬ä¿¡æ¯
    version INTEGER DEFAULT 1,
    parent_template_id UUID REFERENCES templates(id), -- çˆ¶æ¨¡æ¿ID

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    published_at TIMESTAMP,

    -- çº¦æŸ
    CONSTRAINT templates_category_check CHECK (category IN ('tender', 'proposal', 'contract', 'report', 'other')),
    CONSTRAINT templates_rating_check CHECK (rating >= 0 AND rating <= 5)
);

-- æ–‡æ¡£è¡¨
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    template_id UUID REFERENCES templates(id),
    created_by UUID NOT NULL REFERENCES users(id),
    updated_by UUID REFERENCES users(id),

    -- åŸºæœ¬ä¿¡æ¯
    title VARCHAR(200) NOT NULL,
    document_type VARCHAR(50) NOT NULL, -- 'tender_analysis', 'bid_document', 'supporting_document'
    file_name VARCHAR(500),
    file_path VARCHAR(1000),
    file_size BIGINT,
    file_type VARCHAR(50), -- 'pdf', 'docx', 'xlsx', 'txt'
    mime_type VARCHAR(100),

    -- æ–‡æ¡£çŠ¶æ€
    status VARCHAR(20) NOT NULL DEFAULT 'draft', -- 'draft', 'review', 'approved', 'final', 'archived'
    version INTEGER DEFAULT 1,
    parent_document_id UUID REFERENCES documents(id), -- çˆ¶æ–‡æ¡£ID

    -- æ–‡æ¡£å†…å®¹
    content JSONB, -- ç»“æ„åŒ–å†…å®¹
    raw_content TEXT, -- åŸå§‹æ–‡æœ¬å†…å®¹
    analysis_result JSONB, -- AIåˆ†æç»“æœ

    -- è´¨é‡æŒ‡æ ‡
    quality_score DECIMAL(5,2), -- è´¨é‡è¯„åˆ†
    completeness_score DECIMAL(5,2), -- å®Œæ•´æ€§è¯„åˆ†
    ai_generated BOOLEAN DEFAULT false,

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- çº¦æŸ
    CONSTRAINT documents_status_check CHECK (status IN ('draft', 'review', 'approved', 'final', 'archived')),
    CONSTRAINT documents_type_check CHECK (document_type IN ('tender_analysis', 'bid_document', 'supporting_document', 'template'))
);

-- ä¼ä¸šèƒ½åŠ›åº“è¡¨
CREATE TABLE enterprise_capabilities (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    created_by UUID NOT NULL REFERENCES users(id),
    updated_by UUID REFERENCES users(id),

    -- åŸºæœ¬ä¿¡æ¯
    name VARCHAR(200) NOT NULL,
    type VARCHAR(50) NOT NULL, -- 'product', 'service', 'project', 'personnel', 'technology', 'certification'
    category VARCHAR(100),
    subcategory VARCHAR(100),

    -- è¯¦ç»†ä¿¡æ¯
    description TEXT,
    specifications JSONB, -- æŠ€æœ¯è§„æ ¼
    features JSONB DEFAULT '[]', -- ç‰¹æ€§åˆ—è¡¨
    benefits JSONB DEFAULT '[]', -- ä¼˜åŠ¿åˆ—è¡¨
    limitations JSONB DEFAULT '[]', -- å±€é™æ€§

    -- èƒ½åŠ›çº§åˆ«
    proficiency_level INTEGER DEFAULT 3, -- 1-5çº§
    experience_years INTEGER,
    case_study_count INTEGER DEFAULT 0,

    -- æ ‡ç­¾å’Œåˆ†ç±»
    tags TEXT[] DEFAULT '{}',
    keywords TEXT[] DEFAULT '{}',
    industry_focus TEXT[] DEFAULT '{}',

    -- å‘é‡åŒ–æ•°æ®
    embedding_vector VECTOR(1536), -- ç”¨äºè¯­ä¹‰æœç´¢

    -- å…³è”æ•°æ®
    related_capabilities UUID[], -- å…³è”èƒ½åŠ›ID
    applicable_projects UUID[], -- é€‚ç”¨é¡¹ç›®ID
    required_certifications TEXT[], -- æ‰€éœ€è®¤è¯

    -- çŠ¶æ€å’Œå¯ç”¨æ€§
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    availability_status VARCHAR(20) DEFAULT 'available', -- 'available', 'limited', 'unavailable'

    -- ä½¿ç”¨ç»Ÿè®¡
    usage_count INTEGER DEFAULT 0,
    success_rate DECIMAL(5,2), -- æˆåŠŸç‡
    client_satisfaction DECIMAL(5,2), -- å®¢æˆ·æ»¡æ„åº¦

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used_at TIMESTAMP,

    -- çº¦æŸ
    CONSTRAINT capabilities_type_check CHECK (type IN ('product', 'service', 'project', 'personnel', 'technology', 'certification')),
    CONSTRAINT capabilities_level_check CHECK (proficiency_level >= 1 AND proficiency_level <= 5),
    CONSTRAINT capabilities_availability_check CHECK (availability_status IN ('available', 'limited', 'unavailable'))
);

-- AIåŠ©æ‰‹é…ç½®è¡¨
CREATE TABLE ai_assistants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    company_id UUID REFERENCES companies(id) ON DELETE CASCADE, -- NULLè¡¨ç¤ºç³»ç»Ÿé¢„å®šä¹‰
    created_by UUID NOT NULL REFERENCES users(id),

    -- åŸºæœ¬ä¿¡æ¯
    name VARCHAR(200) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL, -- 'system', 'template', 'instance', 'temporary'
    category VARCHAR(100), -- 'analysis', 'generation', 'review', 'optimization'

    -- AIé…ç½®
    model_name VARCHAR(100) NOT NULL, -- 'gpt-4', 'gpt-3.5-turbo', 'claude-2', etc.
    model_version VARCHAR(50),
    temperature DECIMAL(3,2) DEFAULT 0.7,
    max_tokens INTEGER DEFAULT 2000,
    top_p DECIMAL(3,2) DEFAULT 1.0,

    -- æç¤ºè¯é…ç½®
    system_prompt TEXT,
    user_prompt_template TEXT,
    context_template TEXT,
    output_format_template TEXT,

    -- èƒ½åŠ›é…ç½®
    capabilities JSONB DEFAULT '[]', -- èƒ½åŠ›åˆ—è¡¨
    expertise_domains TEXT[] DEFAULT '{}', -- ä¸“ä¸šé¢†åŸŸ
    languages TEXT[] DEFAULT '{zh-CN}', -- æ”¯æŒè¯­è¨€

    -- ä½¿ç”¨é™åˆ¶
    daily_usage_limit INTEGER,
    monthly_usage_limit INTEGER,
    cost_per_use DECIMAL(10,4) DEFAULT 0.0,

    -- æ€§èƒ½æŒ‡æ ‡
    average_response_time INTEGER, -- æ¯«ç§’
    success_rate DECIMAL(5,2) DEFAULT 0.0,
    user_satisfaction DECIMAL(5,2) DEFAULT 0.0,

    -- çŠ¶æ€
    is_active BOOLEAN DEFAULT true,
    is_public BOOLEAN DEFAULT false,
    is_default BOOLEAN DEFAULT false,

    -- ç³»ç»Ÿå­—æ®µ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used_at TIMESTAMP,

    -- çº¦æŸ
    CONSTRAINT ai_assistants_type_check CHECK (type IN ('system', 'template', 'instance', 'temporary')),
    CONSTRAINT ai_assistants_temperature_check CHECK (temperature >= 0 AND temperature <= 2),
    CONSTRAINT ai_assistants_top_p_check CHECK (top_p > 0 AND top_p <= 1)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_users_company_id ON users(company_id);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_created_at ON users(created_at);

CREATE INDEX idx_projects_company_id ON projects(company_id);
CREATE INDEX idx_projects_created_by ON projects(created_by);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_deadline ON projects(submission_deadline);
CREATE INDEX idx_projects_created_at ON projects(created_at);

CREATE INDEX idx_project_members_project_id ON project_members(project_id);
CREATE INDEX idx_project_members_user_id ON project_members(user_id);
CREATE INDEX idx_project_members_role ON project_members(role);

CREATE INDEX idx_templates_company_id ON templates(company_id);
CREATE INDEX idx_templates_category ON templates(category);
CREATE INDEX idx_templates_industry ON templates(industry);
CREATE INDEX idx_templates_is_public ON templates(is_public);
CREATE INDEX idx_templates_created_at ON templates(created_at);

CREATE INDEX idx_documents_project_id ON documents(project_id);
CREATE INDEX idx_documents_template_id ON documents(template_id);
CREATE INDEX idx_documents_created_by ON documents(created_by);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_documents_type ON documents(document_type);
CREATE INDEX idx_documents_created_at ON documents(created_at);

CREATE INDEX idx_enterprise_capabilities_company_id ON enterprise_capabilities(company_id);
CREATE INDEX idx_enterprise_capabilities_type ON enterprise_capabilities(type);
CREATE INDEX idx_enterprise_capabilities_category ON enterprise_capabilities(category);
CREATE INDEX idx_enterprise_capabilities_tags ON enterprise_capabilities USING GIN(tags);
CREATE INDEX idx_enterprise_capabilities_embedding ON enterprise_capabilities USING ivfflat (embedding_vector vector_cosine_ops);

CREATE INDEX idx_ai_assistants_company_id ON ai_assistants(company_id);
CREATE INDEX idx_ai_assistants_type ON ai_assistants(type);
CREATE INDEX idx_ai_assistants_category ON ai_assistants(category);
CREATE INDEX idx_ai_assistants_is_active ON ai_assistants(is_active);

-- åˆ›å»ºè§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- ä¸ºéœ€è¦çš„è¡¨åˆ›å»ºæ›´æ–°æ—¶é—´è§¦å‘å™¨
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_companies_updated_at BEFORE UPDATE ON companies
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON templates
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_documents_updated_at BEFORE UPDATE ON documents
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_enterprise_capabilities_updated_at BEFORE UPDATE ON enterprise_capabilities
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ai_assistants_updated_at BEFORE UPDATE ON ai_assistants
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- åˆ›å»ºè§†å›¾
CREATE VIEW project_summary AS
SELECT
    p.id,
    p.name,
    p.status,
    p.priority,
    p.submission_deadline,
    p.budget_amount,
    p.client_name,
    p.project_type,
    c.name as company_name,
    u.full_name as created_by_name,
    COUNT(pm.user_id) as member_count,
    COUNT(d.id) as document_count,
    p.created_at,
    p.updated_at
FROM projects p
JOIN companies c ON p.company_id = c.id
JOIN users u ON p.created_by = u.id
LEFT JOIN project_members pm ON p.id = pm.project_id AND pm.status = 'active'
LEFT JOIN documents d ON p.id = d.project_id
GROUP BY p.id, c.name, u.full_name;

CREATE VIEW user_project_summary AS
SELECT
    u.id as user_id,
    u.full_name,
    u.email,
    c.name as company_name,
    COUNT(p.id) as total_projects,
    COUNT(CASE WHEN p.status IN ('won', 'lost') THEN 1 END) as completed_projects,
    COUNT(CASE WHEN p.status = 'won' THEN 1 END) as won_projects,
    COUNT(CASE WHEN p.status = 'active' THEN 1 END) as active_projects,
    MAX(p.updated_at) as last_project_activity
FROM users u
JOIN companies c ON u.company_id = c.id
LEFT JOIN project_members pm ON u.id = pm.user_id AND pm.status = 'active'
LEFT JOIN projects p ON pm.project_id = p.id
GROUP BY u.id, c.name, u.full_name, u.email;

-- åˆ›å»ºè¡Œçº§å®‰å…¨ç­–ç•¥
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE enterprise_capabilities ENABLE ROW LEVEL SECURITY;

-- åˆ›å»ºRLSç­–ç•¥
CREATE POLICY company_projects_policy ON projects
    FOR ALL TO authenticated_users
    USING (company_id = current_setting('app.current_company_id')::uuid);

CREATE POLICY company_documents_policy ON documents
    FOR ALL TO authenticated_users
    USING (company_id = current_setting('app.current_company_id')::uuid);

CREATE POLICY company_capabilities_policy ON enterprise_capabilities
    FOR ALL TO authenticated_users
    USING (company_id = current_setting('app.current_company_id')::uuid);
```

è¿™ä»½è¯¦ç»†çš„æŠ€æœ¯æ¶æ„å®ç°æ–‡æ¡£æ¶µç›–äº†å‰ç«¯ã€åç«¯ã€æ•°æ®åº“è®¾è®¡çš„å„ä¸ªå±‚é¢ï¼Œä¸ºå®é™…çš„å¼€å‘å®æ–½æä¾›äº†å…·ä½“çš„æŠ€æœ¯æŒ‡å¯¼ã€‚
TodoWrite
<arg_key>todos</arg_key>
<arg_value>[{"content": "ç»†åŒ–æŠ€æœ¯æ¶æ„å®ç°ç»†èŠ‚", "status": "completed", "activeForm": "ç»†åŒ–æŠ€æœ¯æ¶æ„å®ç°ç»†èŠ‚"}, {"content": "å®Œå–„AIç®—æ³•å’Œæ¨¡å‹è®¾è®¡", "status": "in_progress", "activeForm": "å®Œå–„AIç®—æ³•å’Œæ¨¡å‹è®¾è®¡"}, {"content": "è¯¦ç»†è®¾è®¡æ•°æ®æ¨¡å‹å’ŒAPIæ¥å£", "status": "pending", "activeForm": "è¯¦ç»†è®¾è®¡æ•°æ®æ¨¡å‹å’ŒAPIæ¥å£"}, {"content": "åˆ¶å®šè¯¦ç»†çš„å¸‚åœºæ¨å¹¿ç­–ç•¥", "status": "pending", "activeForm": "åˆ¶å®šè¯¦ç»†çš„å¸‚åœºæ¨å¹¿ç­–ç•¥"}, {"content": "è®¾è®¡è¯¦ç»†çš„è´¢åŠ¡æ¨¡å‹å’ŒKPIä½“ç³»", "status": "pending", "activeForm": "è®¾è®¡è¯¦ç»†çš„è´¢åŠ¡æ¨¡å‹å’ŒKPIä½“ç³»"}]