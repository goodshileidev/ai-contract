# Python FastAPI AI 服务任务详细计划 - AI-003 - AI-003: 企业能力库向量化 - 二级任务 3.1: 产品服务向量化 - 3) Java后端

##### Service层
```java
// CapabilityService.java
@Service
@RequiredArgsConstructor
@Slf4j
public class CapabilityService {

    private final CapabilityMapper capabilityMapper;
    private final RabbitTemplate rabbitTemplate;

    /**
     * 创建产品能力
     * 需求编号: REQ-AI-003
     */
    public CompanyCapability createProduct(CreateProductRequest request) {
        log.info("Creating product capability: {}", request.getName());

        CompanyCapability capability = new CompanyCapability();
        capability.setOrganizationId(request.getOrganizationId());
        capability.setCapabilityType("product");
        capability.setName(request.getName());
        capability.setCategory(request.getCategory());
        capability.setDescription(request.getDescription());
        capability.setFeatures(request.getFeatures());
        capability.setSpecifications(request.getSpecifications());
        capability.setAdvantages(request.getAdvantages());
        capability.setApplicationScenarios(request.getApplicationScenarios());
        capability.setTechnologyStack(request.getTechnologyStack());
        capability.setTags(request.getTags());
        capability.setEmbeddingStatus("pending");
        capability.setIsActive(true);

        capabilityMapper.insert(capability);

        // 发送RabbitMQ消息到Python AI服务进行向量化
        VectorizeMessage message = VectorizeMessage.builder()
            .capabilityId(capability.getId())
            .capabilityType("product")
            .organizationId(capability.getOrganizationId())
            .build();

        rabbitTemplate.convertAndSend(
            "ai.vectorize.exchange",
            "vectorize.product",
            message
        );

        log.info("Vectorization task sent for capability: {}", capability.getId());

        return capability;
    }

    /**
     * 批量向量化
     * 需求编号: REQ-AI-003
     */
    public BatchVectorizeResponse batchVectorize(List<String> capabilityIds) {
        log.info("Batch vectorizing {} capabilities", capabilityIds.size());

        List<CompanyCapability> capabilities = capabilityMapper.selectBatchIds(capabilityIds);

        int successCount = 0;
        List<String> failedIds = new ArrayList<>();

        for (CompanyCapability capability : capabilities) {
            try {
                VectorizeMessage message = VectorizeMessage.builder()
                    .capabilityId(capability.getId())
                    .capabilityType(capability.getCapabilityType())
                    .organizationId(capability.getOrganizationId())
                    .build();

                rabbitTemplate.convertAndSend(
                    "ai.vectorize.exchange",
                    "vectorize." + capability.getCapabilityType(),
                    message
                );

                // 更新状态为pending
                capability.setEmbeddingStatus("pending");
                capabilityMapper.updateById(capability);

                successCount++;
            } catch (Exception e) {
                log.error("Failed to send vectorize message for capability: {}", capability.getId(), e);
                failedIds.add(capability.getId());
            }
        }

        return BatchVectorizeResponse.builder()
            .totalCount(capabilityIds.size())
            .successCount(successCount)
            .failedCount(failedIds.size())
            .failedIds(failedIds)
            .build();
    }

    /**
     * 向量化完成回调（由Python服务调用）
     * 需求编号: REQ-AI-003
     */
    public void onVectorizeComplete(VectorizeCallbackRequest request) {
        log.info("Vectorization completed for capability: {}, status: {}",
            request.getCapabilityId(), request.getStatus());

        CompanyCapability capability = capabilityMapper.selectById(request.getCapabilityId());
        if (capability == null) {
            log.warn("Capability not found: {}", request.getCapabilityId());
            return;
        }

        capability.setEmbeddingStatus(request.getStatus());
        capability.setVectorizedAt(LocalDateTime.now());

        capabilityMapper.updateById(capability);
    }
}
```

##### Controller层
```java
// CapabilityController.java
@RestController
@RequestMapping("/api/v1/capabilities")
@RequiredArgsConstructor
@Slf4j
public class CapabilityController {

    private final CapabilityService capabilityService;

    /**
     * 创建产品能力
     * 需求编号: REQ-AI-003
     */
    @PostMapping("/products")
    public ResponseEntity<ApiResponse<CompanyCapability>> createProduct(
        @RequestBody @Valid CreateProductRequest request
    ) {
        CompanyCapability capability = capabilityService.createProduct(request);
        return ResponseEntity.ok(ApiResponse.success(capability, "产品创建成功"));
    }

    /**
     * 批量向量化
     * 需求编号: REQ-AI-003
     */
    @PostMapping("/vectorize/batch")
    public ResponseEntity<ApiResponse<BatchVectorizeResponse>> batchVectorize(
        @RequestBody @Valid BatchVectorizeRequest request
    ) {
        BatchVectorizeResponse response = capabilityService.batchVectorize(request.getCapabilityIds());
        return ResponseEntity.ok(ApiResponse.success(response, "批量向量化任务已提交"));
    }

    /**
     * 向量化完成回调
     * 需求编号: REQ-AI-003
     * 由Python AI服务调用
     */
    @PostMapping("/vectorize/callback")
    public ResponseEntity<ApiResponse<Void>> vectorizeCallback(
        @RequestBody @Valid VectorizeCallbackRequest request
    ) {
        capabilityService.onVectorizeComplete(request);
        return ResponseEntity.ok(ApiResponse.success(null, "回调处理成功"));
    }
}
```

**验证标准**:
- [ ] 创建产品能力后能成功发送RabbitMQ消息
- [ ] 批量向量化能正确处理多个能力
- [ ] 回调接口能正确更新向量化状态
- [ ] 单元测试覆盖率>80%
