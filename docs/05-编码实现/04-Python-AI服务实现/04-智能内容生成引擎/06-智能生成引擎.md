# Python FastAPI AI 服务任务详细计划 - AI-002 - AI-002: 智能内容生成引擎 - 二级任务 2.2: 智能生成引擎

**预计工作量**: 6 人天
**完成进度**: 0% (0/5 类别)

#### 2.2.1 数据定义

**待完成任务**:
- [ ] 定义内容生成请求/响应模型
  ```python
  # apps/backend-python/app/models/generation.py
  from pydantic import BaseModel
  from typing import List, Dict, Any, Optional
  from enum import Enum

  class GenerationType(str, Enum):
      """生成类型"""
      TECHNICAL_SOLUTION = "technical_solution"  # 技术方案
      IMPLEMENTATION_PLAN = "implementation_plan"  # 实施方案
      TEAM_INTRODUCTION = "team_introduction"  # 团队介绍
      CASE_REFERENCE = "case_reference"  # 案例引用

  class GenerationRequest(BaseModel):
      """内容生成请求"""
      generation_type: GenerationType
      project_id: str
      document_id: str
      section_id: Optional[str]
      requirements: List[Dict[str, Any]]  # 招标需求
      context: Dict[str, Any]  # 额外上下文
      word_count: Optional[int] = 500  # 目标字数

  class GenerationResponse(BaseModel):
      """内容生成响应"""
      task_id: str
      generated_content: str
      tokens_used: int
      generation_time: float  # 秒
      quality_score: float  # 0-100
      suggestions: List[str]  # 改进建议
  ```

- [ ] PostgreSQL生成历史表（Java服务管理）
  ```sql
  CREATE TABLE ai_generation_history (
      id UUID PRIMARY KEY,
      project_id UUID NOT NULL,
      document_id UUID NOT NULL,
      generation_type VARCHAR(50),
      prompt_used TEXT,
      generated_content TEXT,
      tokens_used INT,
      generation_time FLOAT,
      created_by UUID,
      created_at TIMESTAMP WITH TIME ZONE,
      FOREIGN KEY (project_id) REFERENCES projects(id),
      FOREIGN KEY (document_id) REFERENCES bid_documents(id)
  );
  ```

#### 2.2.2 前端实现

**待完成任务**:
- [ ] 创建AI生成触发按钮组件
  ```typescript
  // apps/frontend/src/components/ai/GenerateButton.tsx
  import { Button, Modal, Spin } from 'antd';
  import { RobotOutlined } from '@ant-design/icons';

  interface Props {
      generationType: string;
      projectId: string;
      documentId: string;
      onSuccess: (content: string) => void;
  }

  export function GenerateButton({ generationType, projectId, documentId, onSuccess }: Props) {
      const [generating, setGenerating] = useState(false);
      const [modalVisible, setModalVisible] = useState(false);

      const handleGenerate = async () => {
          setGenerating(true);
          setModalVisible(true);

          try {
              const response = await fetch('http://localhost:8001/api/v1/ai/generate-content', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                      generation_type: generationType,
                      project_id: projectId,
                      document_id: documentId,
                      word_count: 800
                  })
              });

              const result = await response.json();

              // 轮询任务状态
              const taskId = result.task_id;
              const pollResult = await pollTaskStatus(taskId);

              if (pollResult.status === 'success') {
                  onSuccess(pollResult.generated_content);
                  message.success('内容生成成功！');
              } else {
                  message.error('生成失败: ' + pollResult.error);
              }
          } catch (error) {
              message.error('生成失败');
          } finally {
              setGenerating(false);
              setModalVisible(false);
          }
      };

      const pollTaskStatus = async (taskId: string): Promise<any> => {
          // 轮询任务状态直到完成
          while (true) {
              const response = await fetch(`http://localhost:8001/api/v1/ai/tasks/${taskId}`);
              const result = await response.json();

              if (result.status === 'success' || result.status === 'failed') {
                  return result;
              }

              await new Promise(resolve => setTimeout(resolve, 2000));  // 等待2秒
          }
      };

      return (
          <>
              <Button
                  type="primary"
                  icon={<RobotOutlined />}
                  onClick={handleGenerate}
                  loading={generating}
              >
                  AI生成
              </Button>

              <Modal
                  title="AI正在生成内容..."
                  visible={modalVisible}
                  footer={null}
                  closable={false}
              >
                  <div style={{ textAlign: 'center', padding: '40px 0' }}>
                      <Spin size="large" />
                      <p style={{ marginTop: 20 }}>请稍候，AI正在分析需求并生成内容...</p>
                  </div>
              </Modal>
          </>
      );
  }
  ```

- [ ] 创建生成结果预览和编辑界面
  ```typescript
  // apps/frontend/src/components/ai/GeneratedContentPreview.tsx
  import { Card, Button, Rate } from 'antd';
  import { CheckOutlined, EditOutlined } from '@ant-design/icons';

  interface Props {
      content: string;
      qualityScore: number;
      suggestions: string[];
      onAccept: () => void;
      onEdit: () => void;
  }

  export function GeneratedContentPreview({ content, qualityScore, suggestions, onAccept, onEdit }: Props) {
      return (
          <Card
              title="AI生成内容预览"
              extra={
                  <div>
                      <Button icon={<EditOutlined />} onClick={onEdit} style={{ marginRight: 8 }}>
                          编辑
                      </Button>
                      <Button type="primary" icon={<CheckOutlined />} onClick={onAccept}>
                          接受并插入
                      </Button>
                  </div>
              }
          >
              <div>
                  <p><strong>质量评分:</strong> <Rate disabled value={qualityScore / 20} /></p>
                  <div style={{ marginTop: 16, padding: 16, background: '#f5f5f5', borderRadius: 4 }}>
                      {content}
                  </div>
                  {suggestions.length > 0 && (
                      <div style={{ marginTop: 16 }}>
                          <strong>改进建议:</strong>
                          <ul>
                              {suggestions.map((suggestion, idx) => (
                                  <li key={idx}>{suggestion}</li>
                              ))}
                          </ul>
                      </div>
                  )}
              </div>
          </Card>
      );
  }
  ```

#### 2.2.3 Java后端实现

**待完成任务**:
- [ ] 创建 `AIGenerationHistory` 实体
  ```java
  @Data
  @TableName("ai_generation_history")
  public class AIGenerationHistory extends BaseEntity {
      @TableField("project_id")
      private String projectId;

      @TableField("document_id")
      private String documentId;

      @TableField("generation_type")
      private String generationType;

      @TableField("prompt_used")
      private String promptUsed;

      @TableField("generated_content")
      private String generatedContent;

      @TableField("tokens_used")
      private Integer tokensUsed;

      @TableField("generation_time")
      private Double generationTime;
  }
  ```

- [ ] 创建REST API保存生成历史
  ```java
  @RestController
  @RequestMapping("/api/v1/ai-generation-history")
  public class GenerationHistoryController {

      @PostMapping
      public Result<Void> save(@RequestBody SaveHistoryRequest request) {
          // Python服务回调：保存生成历史
          AIGenerationHistory history = new AIGenerationHistory();
          history.setProjectId(request.getProjectId());
          history.setDocumentId(request.getDocumentId());
          history.setGenerationType(request.getGenerationType());
          history.setGeneratedContent(request.getGeneratedContent());
          history.setTokensUsed(request.getTokensUsed());

          historyMapper.insert(history);
          return Result.success();
      }

      @GetMapping
      public Result<List<AIGenerationHistory>> list(@RequestParam String documentId) {
          // 查询文档的生成历史
          return Result.success(historyService.listByDocumentId(documentId));
      }
  }
  ```

#### 2.2.4 Python后端实现

**待完成任务**:
- [ ] 实现智能生成服务
  ```python
  # apps/backend-python/app/services/ai/generation_service.py
  from app.services.ai.rag_service import RAGService
  from llama_index.llms import OpenAI
  import time

  class GenerationService:
      """智能内容生成服务"""

      def __init__(self):
          self.rag_service = RAGService()
          self.llm = OpenAI(model="gpt-4-turbo-preview", api_key=settings.OPENAI_API_KEY)

      async def generate_technical_solution(
          self,
          requirements: List[Dict[str, Any]],
          organization_id: str,
          word_count: int = 800
      ) -> GenerationResponse:
          """
          生成技术方案
          需求编号: REQ-AI-002
          """
          start_time = time.time()

          # 1. 提取需求关键词
          requirements_text = "\n".join([
              f"- {req['title']}: {req['description']}"
              for req in requirements
          ])

          # 2. RAG检索相关能力和案例
          context = await self.rag_service.retrieve(
              query=requirements_text,
              top_k=10,
              organization_id=organization_id
          )

          # 3. 构建生成Prompt
          prompt = f"""
你是一位专业的标书技术方案撰写专家。

招标技术要求：
{requirements_text}

企业相关能力和案例（供参考）：
{self._format_context(context)}

请基于以上招标要求和企业能力，撰写一份专业的技术方案。

要求：
1. 字数约{word_count}字
2. 紧密贴合招标需求
3. 突出企业技术优势
4. 结构清晰，逻辑严密
5. 使用专业术语
6. 引用具体案例增强说服力

请直接输出技术方案内容：
"""

          # 4. 调用GPT-4生成
          response = await self.llm.acomplete(prompt)
          generated_content = response.text

          # 5. 质量评估
          quality_score = await self._evaluate_quality(generated_content, requirements)

          # 6. 生成改进建议
          suggestions = await self._generate_suggestions(generated_content, requirements)

          generation_time = time.time() - start_time

          return GenerationResponse(
              task_id="",  # 由Celery任务ID填充
              generated_content=generated_content,
              tokens_used=response.additional_kwargs.get('usage', {}).get('total_tokens', 0),
              generation_time=generation_time,
              quality_score=quality_score,
              suggestions=suggestions
          )

      def _format_context(self, context: RAGContext) -> str:
          """格式化RAG上下文"""
          formatted = []
          for doc in context.retrieved_docs:
              formatted.append(f"[{doc['title']}]\n{doc['content']}\n")
          return "\n".join(formatted)

      async def _evaluate_quality(
          self,
          content: str,
          requirements: List[Dict[str, Any]]
      ) -> float:
          """评估生成内容质量（0-100）"""
          # 使用LLM评估质量
          eval_prompt = f"""
请评估以下技术方案的质量（0-100分）：

技术方案：
{content}

原始需求：
{requirements}

评估维度：
1. 与需求的匹配度（40分）
2. 内容的专业性（30分）
3. 逻辑的严密性（20分）
4. 语言的流畅性（10分）

请只返回一个0-100的分数。
"""

          response = await self.llm.acomplete(eval_prompt)
          try:
              score = float(response.text.strip())
              return min(max(score, 0), 100)
          except:
              return 75.0  # 默认分数

      async def _generate_suggestions(
          self,
          content: str,
          requirements: List[Dict[str, Any]]
      ) -> List[str]:
          """生成改进建议"""
          suggestions_prompt = f"""
请为以下技术方案提供3-5条改进建议：

技术方案：
{content}

请列出具体的改进建议（每条不超过30字）：
"""

          response = await self.llm.acomplete(suggestions_prompt)
          suggestions = [
              line.strip().lstrip('123456789.- ')
              for line in response.text.strip().split('\n')
              if line.strip()
          ]
          return suggestions[:5]
  ```

- [ ] 创建Celery生成任务
  ```python
  # apps/backend-python/app/tasks/generation.py
  @celery_app.task(bind=True)
  def generate_content_task(
      self: Task,
      generation_type: str,
      project_id: str,
      document_id: str,
      requirements: List[Dict],
      word_count: int = 800
  ):
      """
      内容生成任务
      需求编号: REQ-AI-002
      """
      try:
          generation_service = GenerationService()
          java_client = JavaAPIClient()

          # 1. 获取组织ID
          project = await java_client.get_project(project_id)
          organization_id = project['organization_id']

          # 2. 执行生成
          if generation_type == 'technical_solution':
              result = await generation_service.generate_technical_solution(
                  requirements=requirements,
                  organization_id=organization_id,
                  word_count=word_count
              )
          # elif ...其他生成类型

          # 3. 保存到Java服务
          await java_client.save_generation_history({
              'project_id': project_id,
              'document_id': document_id,
              'generation_type': generation_type,
              'generated_content': result.generated_content,
              'tokens_used': result.tokens_used
          })

          return {
              'status': 'success',
              'generated_content': result.generated_content,
              'quality_score': result.quality_score,
              'suggestions': result.suggestions
          }

      except Exception as e:
          return {'status': 'failed', 'error': str(e)}
  ```

- [ ] 创建API端点
  ```python
  # apps/backend-python/app/api/v1/generation.py
  @router.post("/generate-content")
  async def generate_content(request: GenerationRequest):
      """
      触发内容生成
      需求编号: REQ-AI-002
      """
      from app.tasks.generation import generate_content_task

      # 异步生成任务
      task = generate_content_task.delay(
          generation_type=request.generation_type,
          project_id=request.project_id,
          document_id=request.document_id,
          requirements=request.requirements,
          word_count=request.word_count
      )

      return {
          "task_id": task.id,
          "status": "processing",
          "message": "内容生成任务已提交"
      }

  @router.get("/tasks/{task_id}")
  async def get_task_status(task_id: str):
      """获取任务状态"""
      from app.tasks.celery_app import celery_app

      task = celery_app.AsyncResult(task_id)

      if task.ready():
          return {
              "status": "success" if task.successful() else "failed",
              **task.result
          }
      else:
          return {
              "status": "processing",
              "progress": 50  # 可以更精细地跟踪进度
          }
  ```

#### 2.2.5 部署配置

**待完成任务**:
- [ ] 配置Celery生成队列
  ```python
  celery_app.conf.task_routes = {
      'app.tasks.generation.generate_content_task': {'queue': 'generation'},
  }
  ```

- [ ] 启动生成Worker
  ```bash
  # docker-compose.yml
  generation-worker:
    build:
      context: ./apps/backend-python
    command: celery -A app.tasks.celery_app worker --loglevel=info -Q generation -c 2
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - rabbitmq
      - redis
  ```

**验收标准**:
- [ ] 技术方案生成成功
- [ ] 生成内容质量评分准确
- [ ] 改进建议合理
- [ ] 生成任务可追踪

---
