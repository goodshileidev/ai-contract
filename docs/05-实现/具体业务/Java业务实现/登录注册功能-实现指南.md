# Java Spring Boot æœåŠ¡ä»»åŠ¡è¯¦ç»†è®¡åˆ’ - JAVA-001 Part1

**æ–‡æ¡£ç±»å‹**: å®æ–½æ–‡æ¡£
**éœ€æ±‚ç¼–å·**: REQ-JAVA-001 (å­ä»»åŠ¡ 1.1-1.3)
**åˆ›å»ºæ—¥æœŸ**: 2025-11-26
**åˆ›å»ºè€…**: claude-sonnet-4-5 (claude-sonnet-4-5-20250929)
**æœ€åæ›´æ–°**: 2025-11-27
**æ›´æ–°è€…**: claude-sonnet-4-5 (claude-sonnet-4-5-20250929)
**çŠ¶æ€**: å¾…å¼€å§‹

---

## ä¿®æ”¹å†å²

| æ—¥æœŸ | ç‰ˆæœ¬ | ä¿®æ”¹è€… | ä¿®æ”¹å†…å®¹æ¦‚è¦ |
|------|------|--------|-------------|
| 2025-11-27 14:50 | 2.0 | claude-sonnet-4-5 (claude-sonnet-4-5-20250929) | ä» task-plan-java-è¯¦ç»†.md æ‹†åˆ†å‡º Part1 (å­ä»»åŠ¡1.1-1.3) |
| 2025-11-26 | 1.0 | claude-sonnet-4-5 (claude-sonnet-4-5-20250929) | åˆ›å»ºJavaæœåŠ¡è¯¦ç»†ä»»åŠ¡è®¡åˆ’ |

---

## ğŸ“‘ æ–‡æ¡£å¯¼èˆª

**è¿”å›ç´¢å¼•**: [task-plan-java-è¯¦ç»†-INDEX.md](./task-plan-java-è¯¦ç»†-INDEX.md)

**å…¶ä»–éƒ¨åˆ†**:
- [Part2: å­ä»»åŠ¡ 1.4](./task-plan-java-è¯¦ç»†-JAVA-001-Part2.md)
- [Part3: å­ä»»åŠ¡ 1.5-1.6](./task-plan-java-è¯¦ç»†-JAVA-001-Part3.md)

---

## æ¨¡å—æ¦‚è¿°

æœ¬æ–‡æ¡£åŒ…å« **JAVA-001: ç”¨æˆ·è®¤è¯æˆæƒæ¨¡å—** çš„å‰3ä¸ªå­ä»»åŠ¡ï¼š
- 1.1 ç”¨æˆ·ç®¡ç†åŸºç¡€åŠŸèƒ½
- 1.2 Spring Security é›†æˆ
- 1.3 ç™»å½•æ³¨å†ŒåŠŸèƒ½

**æŠ€æœ¯æ ˆ**: Java 17 LTS + Spring Boot 3.2.x + Spring Data JPA + Spring Security 6.x

---

## JAVA-001: ç”¨æˆ·è®¤è¯æˆæƒæ¨¡å—

**éœ€æ±‚ç¼–å·**: REQ-JAVA-001
**è´Ÿè´£äºº**: Java åç«¯å¼€å‘
**ä¼˜å…ˆçº§**: P1 - é«˜ä¼˜å…ˆçº§
**å¼€å§‹æ—¶é—´**: YYYY-MM-DD
**é¢„è®¡å®Œæˆ**: YYYY-MM-DD
**å®é™…å®Œæˆ**: -
**å½“å‰çŠ¶æ€**: â¸ï¸ å¾…å¼€å§‹
**å®Œæˆè¿›åº¦**: 0% (0/6 å­ä»»åŠ¡)

### æ¨¡å—ç›®æ ‡

å®ç°å®Œæ•´çš„ç”¨æˆ·è®¤è¯æˆæƒç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š
- JWT Token è®¤è¯æœºåˆ¶
- åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰
- ç”¨æˆ·æ³¨å†Œç™»å½•æµç¨‹
- ç”¨æˆ·ä¸ªäººä¿¡æ¯ç®¡ç†
- å¯†ç å®‰å…¨ç®¡ç†
- Token åˆ·æ–°å’Œå¤±æ•ˆæœºåˆ¶

### æŠ€æœ¯æ¶æ„

```
å‰ç«¯ (React)
    â†“ POST /api/auth/login
Java Controller (UserController, AuthController)
    â†“
Spring Security Filter Chain
    â†“
JWT Token Service
    â†“
UserDetailsService â†’ PostgreSQL (users, roles, permissions)
    â†“
Redis (Token Storage, Blacklist)
```

### æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜

1. **å®‰å…¨æ€§**: å¯†ç åŠ å¯†ï¼ˆBCryptï¼‰ã€Token å®‰å…¨å­˜å‚¨ã€é˜²æ­¢æš´åŠ›ç ´è§£
2. **æ€§èƒ½**: Token éªŒè¯é«˜é¢‘è°ƒç”¨ã€Redis ç¼“å­˜ä¼˜åŒ–
3. **æ‰©å±•æ€§**: æ”¯æŒå¤šç§è®¤è¯æ–¹å¼ï¼ˆOAuth2ã€SSOï¼‰çš„é¢„ç•™æ¥å£
4. **å¯é æ€§**: Token åˆ·æ–°æœºåˆ¶ã€ä¼˜é›…çš„è¿‡æœŸå¤„ç†

---

## 1.1 ç”¨æˆ·ç®¡ç†åŸºç¡€åŠŸèƒ½

**é¢„è®¡å·¥ä½œé‡**: 5 äººå¤©
**ä¼˜å…ˆçº§**: P1
**ä¾èµ–**: æ— 

### æŠ€æœ¯å®ç°æ¦‚è¿°

å®ç°ç”¨æˆ·å®ä½“æ¨¡å‹ã€æ•°æ®è®¿é—®å±‚å’ŒåŸºç¡€ä¸šåŠ¡é€»è¾‘ï¼Œä¸ºè®¤è¯æˆæƒæä¾›æ•°æ®åŸºç¡€ã€‚

---

### 1.3.1 æ•°æ®å®šä¹‰

#### æ³¨å†Œè¯·æ±‚ DTO

```java
// src/main/java/com/aibidcomposer/dto/auth/RegisterRequest.java
package com.aibidcomposer.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

/**
 * ç”¨æˆ·æ³¨å†Œè¯·æ±‚DTO
 * éœ€æ±‚ç¼–å·: REQ-JAVA-001
 */
@Data
public class RegisterRequest {

    @NotBlank(message = "é‚®ç®±ä¸èƒ½ä¸ºç©º")
    @Email(message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
    private String email;

    @NotBlank(message = "ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
    @Size(min = 3, max = 50, message = "ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨3-50ä¹‹é—´")
    private String username;

    @NotBlank(message = "å¯†ç ä¸èƒ½ä¸ºç©º")
    @Size(min = 8, max = 128, message = "å¯†ç é•¿åº¦å¿…é¡»åœ¨8-128ä¹‹é—´")
    private String password;

    private String fullName;

    private String organizationName;
}
```

#### ç™»å½•è¯·æ±‚/å“åº” DTO

```java
// src/main/java/com/aibidcomposer/dto/auth/LoginRequest.java
package com.aibidcomposer.dto.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * ç™»å½•è¯·æ±‚DTO
 */
@Data
public class LoginRequest {

    @NotBlank(message = "é‚®ç®±æˆ–ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
    private String emailOrUsername;

    @NotBlank(message = "å¯†ç ä¸èƒ½ä¸ºç©º")
    private String password;

    private Boolean rememberMe = false;
}
```

```java
// src/main/java/com/aibidcomposer/dto/auth/LoginResponse.java
package com.aibidcomposer.dto.auth;

import com.aibidcomposer.dto.user.UserResponse;
import lombok.Builder;
import lombok.Data;

/**
 * ç™»å½•å“åº”DTO
 */
@Data
@Builder
public class LoginResponse {
    private String accessToken;
    private String refreshToken;
    private String tokenType;
    private Long expiresIn;
    private UserResponse user;
}
```

#### Token åˆ·æ–°è¯·æ±‚ DTO

```java
// src/main/java/com/aibidcomposer/dto/auth/RefreshTokenRequest.java
package com.aibidcomposer.dto.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * Tokenåˆ·æ–°è¯·æ±‚DTO
 */
@Data
public class RefreshTokenRequest {

    @NotBlank(message = "Refresh Tokenä¸èƒ½ä¸ºç©º")
    private String refreshToken;
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] DTO ç±»å®šä¹‰å®Œæ•´
- [ ] éªŒè¯æ³¨è§£æ­£ç¡®é…ç½®
- [ ] å¯†ç å¼ºåº¦è¦æ±‚åˆç†ï¼ˆâ‰¥8å­—ç¬¦ï¼‰

### 1.3.2 å‰ç«¯

#### ç™»å½•é¡µé¢ï¼ˆProFormï¼‰

```typescript
// frontend/src/pages/Auth/Login.tsx
import React from 'react';
import { ProForm, ProFormText, ProFormCheckbox } from '@ant-design/pro-components';
import { message } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { useNavigate, Link } from 'react-router-dom';
import { authService, LoginRequest } from '@/services/auth.service';
import { TokenStorage } from '@/utils/auth';
import './Login.css';

/**
 * ç™»å½•é¡µé¢
 * éœ€æ±‚ç¼–å·: REQ-JAVA-001
 */
const LoginPage: React.FC = () => {
  const navigate = useNavigate();

  const handleSubmit = async (values: LoginRequest & { remember?: boolean }) => {
    try {
      const { remember, ...loginData } = values;

      // è°ƒç”¨ç™»å½•API
      const response = await authService.login(loginData);

      // ä¿å­˜Token
      TokenStorage.saveTokens(
        response.accessToken,
        response.refreshToken,
        response.expiresIn
      );

      // è®°ä½é‚®ç®±
      if (remember) {
        localStorage.setItem('remember_email', loginData.emailOrUsername);
      } else {
        localStorage.removeItem('remember_email');
      }

      message.success('ç™»å½•æˆåŠŸï¼');

      // è·³è½¬åˆ°å·¥ä½œå°
      navigate('/dashboard');

      return true; // ProFormè¦æ±‚è¿”å›true
    } catch (error: any) {
      message.error(error.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç ');
      return false;
    }
  };

  // è·å–è®°ä½çš„é‚®ç®±
  const rememberedEmail = localStorage.getItem('remember_email');

  return (
    <div className="login-page">
      <div className="login-container">
        <div className="login-header">
          <h2>ç”¨æˆ·ç™»å½•</h2>
          <p>AIæ ‡ä¹¦æ™ºèƒ½åˆ›ä½œå¹³å°</p>
        </div>

        <ProForm
          name="login"
          initialValues={{
            emailOrUsername: rememberedEmail || '',
            remember: !!rememberedEmail,
          }}
          onFinish={handleSubmit}
          submitter={{
            searchConfig: {
              submitText: 'ç™»å½•',
            },
            render: (_, dom) => dom[1], // åªæ˜¾ç¤ºæäº¤æŒ‰é’®
            submitButtonProps: {
              size: 'large',
              block: true,
            },
          }}
          autoFocusFirstInput
        >
          <ProFormText
            name="emailOrUsername"
            fieldProps={{
              size: 'large',
              prefix: <UserOutlined />,
              placeholder: 'é‚®ç®±æˆ–ç”¨æˆ·å',
            }}
            rules={[
              { required: true, message: 'è¯·è¾“å…¥é‚®ç®±æˆ–ç”¨æˆ·å' },
            ]}
          />

          <ProFormText.Password
            name="password"
            fieldProps={{
              size: 'large',
              prefix: <LockOutlined />,
              placeholder: 'å¯†ç ',
            }}
            rules={[
              { required: true, message: 'è¯·è¾“å…¥å¯†ç ' },
            ]}
          />

          <div className="login-options">
            <ProFormCheckbox name="remember">è®°ä½æˆ‘</ProFormCheckbox>
            <Link to="/forgot-password" className="login-forgot">
              å¿˜è®°å¯†ç ?
            </Link>
          </div>

          <div className="login-register" style={{ marginTop: 16 }}>
            è¿˜æ²¡æœ‰è´¦å·? <Link to="/register">ç«‹å³æ³¨å†Œ</Link>
          </div>
        </ProForm>
      </div>
    </div>
  );
};

export default LoginPage;
```

#### æ³¨å†Œé¡µé¢ï¼ˆProFormï¼‰

```typescript
// frontend/src/pages/Auth/Register.tsx
import React from 'react';
import { ProForm, ProFormText } from '@ant-design/pro-components';
import { message } from 'antd';
import { UserOutlined, LockOutlined, MailOutlined } from '@ant-design/icons';
import { useNavigate, Link } from 'react-router-dom';
import { authService, RegisterRequest } from '@/services/auth.service';

/**
 * æ³¨å†Œé¡µé¢
 * éœ€æ±‚ç¼–å·: REQ-JAVA-001
 */
const RegisterPage: React.FC = () => {
  const navigate = useNavigate();

  const handleSubmit = async (values: RegisterRequest) => {
    try {
      await authService.register(values);

      message.success('æ³¨å†ŒæˆåŠŸï¼è¯·ç™»å½•ã€‚');

      // è·³è½¬åˆ°ç™»å½•é¡µ
      navigate('/login');

      return true;
    } catch (error: any) {
      message.error(error.message || 'æ³¨å†Œå¤±è´¥');
      return false;
    }
  };

  return (
    <div className="register-page">
      <div className="register-container">
        <div className="register-header">
          <h2>ç”¨æˆ·æ³¨å†Œ</h2>
          <p>AIæ ‡ä¹¦æ™ºèƒ½åˆ›ä½œå¹³å°</p>
        </div>

        <ProForm
          name="register"
          onFinish={handleSubmit}
          submitter={{
            searchConfig: {
              submitText: 'æ³¨å†Œ',
            },
            render: (_, dom) => dom[1],
            submitButtonProps: {
              size: 'large',
              block: true,
            },
          }}
          autoFocusFirstInput
        >
          <ProFormText
            name="email"
            fieldProps={{
              size: 'large',
              prefix: <MailOutlined />,
              placeholder: 'é‚®ç®±åœ°å€',
            }}
            rules={[
              { required: true, message: 'è¯·è¾“å…¥é‚®ç®±åœ°å€' },
              { type: 'email', message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€' },
            ]}
          />

          <ProFormText
            name="username"
            fieldProps={{
              size: 'large',
              prefix: <UserOutlined />,
              placeholder: 'ç”¨æˆ·å',
            }}
            rules={[
              { required: true, message: 'è¯·è¾“å…¥ç”¨æˆ·å' },
              { min: 3, max: 50, message: 'ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨3-50ä¹‹é—´' },
            ]}
          />

          <ProFormText
            name="fullName"
            fieldProps={{
              size: 'large',
              prefix: <UserOutlined />,
              placeholder: 'å§“åï¼ˆå¯é€‰ï¼‰',
            }}
          />

          <ProFormText.Password
            name="password"
            fieldProps={{
              size: 'large',
              prefix: <LockOutlined />,
              placeholder: 'å¯†ç ï¼ˆè‡³å°‘8ä¸ªå­—ç¬¦ï¼‰',
            }}
            rules={[
              { required: true, message: 'è¯·è¾“å…¥å¯†ç ' },
              { min: 8, message: 'å¯†ç è‡³å°‘8ä¸ªå­—ç¬¦' },
            ]}
          />

          <ProFormText.Password
            name="confirmPassword"
            fieldProps={{
              size: 'large',
              prefix: <LockOutlined />,
              placeholder: 'ç¡®è®¤å¯†ç ',
            }}
            rules={[
              { required: true, message: 'è¯·ç¡®è®¤å¯†ç ' },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´'));
                },
              }),
            ]}
          />

          <div className="register-login" style={{ marginTop: 16 }}>
            å·²æœ‰è´¦å·? <Link to="/login">ç«‹å³ç™»å½•</Link>
          </div>
        </ProForm>
      </div>
    </div>
  );
};

export default RegisterPage;
```

#### è®¤è¯æœåŠ¡ï¼ˆAPI Clientï¼‰

```typescript
// frontend/src/services/auth.service.ts
import axios from 'axios';
import { TokenStorage } from '@/utils/auth';

export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  fullName?: string;
  organizationName?: string;
}

export interface LoginRequest {
  emailOrUsername: string;
  password: string;
  rememberMe?: boolean;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: string;
  expiresIn: number;
  user: {
    id: string;
    email: string;
    username: string;
    fullName: string;
  };
}

class AuthService {
  private baseURL = 'http://localhost:8080/api/v1/auth';

  /**
   * ç”¨æˆ·æ³¨å†Œ
   */
  async register(data: RegisterRequest): Promise<void> {
    await axios.post(`${this.baseURL}/register`, data);
  }

  /**
   * ç”¨æˆ·ç™»å½•
   */
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response = await axios.post<{ success: boolean; data: LoginResponse }>(
      `${this.baseURL}/login`,
      data
    );
    return response.data.data;
  }

  /**
   * ç”¨æˆ·ç™»å‡º
   */
  async logout(): Promise<void> {
    const token = TokenStorage.getAccessToken();
    if (token) {
      await axios.post(`${this.baseURL}/logout`, {}, {
        headers: { Authorization: `Bearer ${token}` },
      });
    }
    TokenStorage.clearTokens();
  }

  /**
   * åˆ·æ–°Token
   */
  async refreshToken(): Promise<LoginResponse> {
    const refreshToken = TokenStorage.getRefreshToken();
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await axios.post<{ success: boolean; data: LoginResponse }>(
      `${this.baseURL}/refresh`,
      { refreshToken }
    );

    return response.data.data;
  }

  /**
   * è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
   */
  async getCurrentUser(): Promise<any> {
    const token = TokenStorage.getAccessToken();
    const response = await axios.get(`${this.baseURL}/me`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return response.data.data;
  }
}

export const authService = new AuthService();
```

**éªŒè¯æ ‡å‡†**:
- [ ] ç™»å½•é¡µé¢æ­£ç¡®æ¸²æŸ“
- [ ] æ³¨å†Œé¡µé¢æ­£ç¡®æ¸²æŸ“
- [ ] è¡¨å•éªŒè¯æ­£ç¡®
- [ ] API è°ƒç”¨æˆåŠŸ
- [ ] Token æ­£ç¡®å­˜å‚¨
- [ ] ç™»å½•æˆåŠŸè·³è½¬åˆ°å·¥ä½œå°
- [ ] è®°ä½æˆ‘åŠŸèƒ½æ­£å¸¸

### 1.3.3 Javaåç«¯

#### AuthServiceï¼ˆè®¤è¯æœåŠ¡ï¼‰

```java
// src/main/java/com/aibidcomposer/service/AuthService.java
package com.aibidcomposer.service;

import com.aibidcomposer.domain.Organization;
import com.aibidcomposer.domain.User;
import com.aibidcomposer.domain.enums.UserStatus;
import com.aibidcomposer.dto.auth.*;
import com.aibidcomposer.exception.AuthenticationFailedException;
import com.aibidcomposer.exception.ValidationException;
import com.aibidcomposer.repository.OrganizationRepository;
import com.aibidcomposer.repository.UserRepository;
import com.aibidcomposer.security.CustomUserDetailsService.CustomUserDetails;
import com.aibidcomposer.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * è®¤è¯æœåŠ¡
 * éœ€æ±‚ç¼–å·: REQ-JAVA-001
 *
 * @author AIBidComposer Team
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class AuthService {

    private final UserRepository userRepository;
    private final OrganizationRepository organizationRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider tokenProvider;
    private final AuthenticationManager authenticationManager;
    private final UserService userService;

    /**
     * ç”¨æˆ·æ³¨å†Œ
     *
     * @param request æ³¨å†Œè¯·æ±‚
     * @return ç”¨æˆ·ID
     * @throws ValidationException éªŒè¯å¤±è´¥
     */
    public UUID register(RegisterRequest request) {
        log.info("ç”¨æˆ·æ³¨å†Œ: email={}, username={}", request.getEmail(), request.getUsername());

        // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ValidationException("é‚®ç®±å·²è¢«ä½¿ç”¨");
        }

        // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ValidationException("ç”¨æˆ·åå·²è¢«ä½¿ç”¨");
        }

        // åˆ›å»ºæˆ–è·å–ç»„ç»‡
        Organization organization = null;
        if (request.getOrganizationName() != null && !request.getOrganizationName().isEmpty()) {
            organization = Organization.builder()
                    .name(request.getOrganizationName())
                    .status(OrganizationStatus.ACTIVE)
                    .build();
            organization = organizationRepository.save(organization);
        }

        // åˆ›å»ºç”¨æˆ·
        User user = User.builder()
                .email(request.getEmail())
                .username(request.getUsername())
                .fullName(request.getFullName())
                .hashedPassword(passwordEncoder.encode(request.getPassword()))
                .status(UserStatus.INACTIVE) // éœ€è¦é‚®ç®±éªŒè¯åæ¿€æ´»
                .emailVerified(false)
                .organization(organization)
                .build();

        user = userRepository.save(user);

        log.info("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: userId={}, email={}", user.getId(), user.getEmail());

        // TODO: å‘é€é‚®ç®±éªŒè¯é‚®ä»¶

        return user.getId();
    }

    /**
     * ç”¨æˆ·ç™»å½•
     *
     * @param request ç™»å½•è¯·æ±‚
     * @param ipAddress å®¢æˆ·ç«¯IPåœ°å€
     * @return ç™»å½•å“åº”ï¼ˆåŒ…å«Tokenï¼‰
     * @throws AuthenticationFailedException è®¤è¯å¤±è´¥
     */
    public LoginResponse login(LoginRequest request, String ipAddress) {
        log.info("ç”¨æˆ·ç™»å½•: emailOrUsername={}", request.getEmailOrUsername());

        try {
            // æŸ¥æ‰¾ç”¨æˆ·
            User user = findUserByEmailOrUsername(request.getEmailOrUsername());

            // æ£€æŸ¥è´¦å·çŠ¶æ€
            if (user.isLocked()) {
                throw new AuthenticationFailedException(
                        "è´¦å·å·²è¢«é”å®šï¼Œè¯·åœ¨" + user.getLockedUntil() + "åé‡è¯•"
                );
            }

            if (user.getStatus() == UserStatus.SUSPENDED) {
                throw new AuthenticationFailedException("è´¦å·å·²è¢«æš‚åœ");
            }

            // æ‰§è¡Œè®¤è¯
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            user.getId().toString(),
                            request.getPassword()
                    )
            );

            CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
            List<? extends GrantedAuthority> authorities = (List<? extends GrantedAuthority>) userDetails.getAuthorities();

            // ç”ŸæˆToken
            String accessToken = tokenProvider.generateAccessToken(user, authorities);
            String refreshToken = tokenProvider.generateRefreshToken(user.getId());

            // è®°å½•ç™»å½•ä¿¡æ¯
            userService.recordLogin(user.getId(), ipAddress);

            log.info("ç”¨æˆ·ç™»å½•æˆåŠŸ: userId={}, email={}", user.getId(), user.getEmail());

            return LoginResponse.builder()
                    .accessToken(accessToken)
                    .refreshToken(refreshToken)
                    .tokenType("Bearer")
                    .expiresIn(3600L) // 1å°æ—¶
                    .user(UserResponse.from(user))
                    .build();

        } catch (Exception ex) {
            log.error("ç”¨æˆ·ç™»å½•å¤±è´¥: {}", ex.getMessage());

            // å¢åŠ å¤±è´¥ç™»å½•æ¬¡æ•°
            try {
                User user = findUserByEmailOrUsername(request.getEmailOrUsername());
                userService.incrementFailedLoginAttempts(user.getId());
            } catch (Exception ignored) {
            }

            throw new AuthenticationFailedException("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯");
        }
    }

    /**
     * åˆ·æ–°Token
     *
     * @param request åˆ·æ–°Tokenè¯·æ±‚
     * @return æ–°çš„Token
     * @throws AuthenticationFailedException Tokenæ— æ•ˆ
     */
    public LoginResponse refreshToken(RefreshTokenRequest request) {
        log.debug("åˆ·æ–°Token");

        // éªŒè¯Refresh Token
        if (!tokenProvider.validateToken(request.getRefreshToken())) {
            throw new AuthenticationFailedException("Refresh Tokenæ— æ•ˆ");
        }

        // æå–ç”¨æˆ·ID
        UUID userId = tokenProvider.getUserIdFromToken(request.getRefreshToken());

        // åŠ è½½ç”¨æˆ·
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new AuthenticationFailedException("ç”¨æˆ·ä¸å­˜åœ¨"));

        // ç”Ÿæˆæ–°çš„Access Token
        // TODO: ä»ç”¨æˆ·è§’è‰²ä¸­æå–æƒé™
        List<GrantedAuthority> authorities = List.of();
        String accessToken = tokenProvider.generateAccessToken(user, authorities);

        log.info("Tokenåˆ·æ–°æˆåŠŸ: userId={}", userId);

        return LoginResponse.builder()
                .accessToken(accessToken)
                .refreshToken(request.getRefreshToken()) // ä¿æŒRefresh Tokenä¸å˜
                .tokenType("Bearer")
                .expiresIn(3600L)
                .user(UserResponse.from(user))
                .build();
    }

    /**
     * ç”¨æˆ·ç™»å‡º
     *
     * @param userId ç”¨æˆ·ID
     */
    public void logout(UUID userId) {
        log.info("ç”¨æˆ·ç™»å‡º: userId={}", userId);

        // TODO: å°†TokenåŠ å…¥é»‘åå•ï¼ˆRedisï¼‰

        log.info("ç”¨æˆ·ç™»å‡ºæˆåŠŸ: userId={}", userId);
    }

    /**
     * æ ¹æ®é‚®ç®±æˆ–ç”¨æˆ·åæŸ¥æ‰¾ç”¨æˆ·
     *
     * @param emailOrUsername é‚®ç®±æˆ–ç”¨æˆ·å
     * @return ç”¨æˆ·å¯¹è±¡
     */
    private User findUserByEmailOrUsername(String emailOrUsername) {
        // å°è¯•ä½œä¸ºé‚®ç®±æŸ¥æ‰¾
        if (emailOrUsername.contains("@")) {
            return userRepository.findByEmail(emailOrUsername)
                    .orElseThrow(() -> new AuthenticationFailedException("ç”¨æˆ·ä¸å­˜åœ¨"));
        }

        // ä½œä¸ºç”¨æˆ·åæŸ¥æ‰¾
        return userRepository.findByUsername(emailOrUsername)
                .orElseThrow(() -> new AuthenticationFailedException("ç”¨æˆ·ä¸å­˜åœ¨"));
    }
}
```

#### AuthControllerï¼ˆè®¤è¯æ§åˆ¶å™¨ï¼‰

```java
// src/main/java/com/aibidcomposer/controller/AuthController.java
package com.aibidcomposer.controller;

import com.aibidcomposer.dto.auth.*;
import com.aibidcomposer.dto.common.ApiResponse;
import com.aibidcomposer.dto.user.UserResponse;
import com.aibidcomposer.security.CustomUserDetailsService.CustomUserDetails;
import com.aibidcomposer.service.AuthService;
import com.aibidcomposer.service.UserService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * è®¤è¯APIæ§åˆ¶å™¨
 * éœ€æ±‚ç¼–å·: REQ-JAVA-001
 *
 * @author AIBidComposer Team
 */
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final AuthService authService;
    private final UserService userService;

    /**
     * ç”¨æˆ·æ³¨å†Œ
     *
     * POST /api/v1/auth/register
     *
     * @param request æ³¨å†Œè¯·æ±‚
     * @return æ³¨å†ŒæˆåŠŸå“åº”
     */
    @PostMapping("/register")
    public ResponseEntity<ApiResponse<UUID>> register(
            @Valid @RequestBody RegisterRequest request
    ) {
        log.info("APIè¯·æ±‚: POST /api/v1/auth/register, email={}", request.getEmail());

        UUID userId = authService.register(request);

        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(ApiResponse.success(userId, "æ³¨å†ŒæˆåŠŸï¼Œè¯·éªŒè¯é‚®ç®±åç™»å½•"));
    }

    /**
     * ç”¨æˆ·ç™»å½•
     *
     * POST /api/v1/auth/login
     *
     * @param request ç™»å½•è¯·æ±‚
     * @param httpRequest HTTPè¯·æ±‚ï¼ˆç”¨äºè·å–IPåœ°å€ï¼‰
     * @return ç™»å½•å“åº”ï¼ˆåŒ…å«Tokenï¼‰
     */
    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(
            @Valid @RequestBody LoginRequest request,
            HttpServletRequest httpRequest
    ) {
        log.info("APIè¯·æ±‚: POST /api/v1/auth/login, emailOrUsername={}",
                 request.getEmailOrUsername());

        String ipAddress = getClientIpAddress(httpRequest);
        LoginResponse response = authService.login(request, ipAddress);

        return ResponseEntity.ok(ApiResponse.success(response, "ç™»å½•æˆåŠŸ"));
    }

    /**
     * åˆ·æ–°Token
     *
     * POST /api/v1/auth/refresh
     *
     * @param request åˆ·æ–°Tokenè¯·æ±‚
     * @return æ–°çš„Token
     */
    @PostMapping("/refresh")
    public ResponseEntity<ApiResponse<LoginResponse>> refreshToken(
            @Valid @RequestBody RefreshTokenRequest request
    ) {
        log.info("APIè¯·æ±‚: POST /api/v1/auth/refresh");

        LoginResponse response = authService.refreshToken(request);

        return ResponseEntity.ok(ApiResponse.success(response, "Tokenåˆ·æ–°æˆåŠŸ"));
    }

    /**
     * ç”¨æˆ·ç™»å‡º
     *
     * POST /api/v1/auth/logout
     *
     * @param userDetails å½“å‰ç”¨æˆ·
     * @return æˆåŠŸå“åº”
     */
    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(
            @AuthenticationPrincipal CustomUserDetails userDetails
    ) {
        UUID userId = userDetails.getUser().getId();
        log.info("APIè¯·æ±‚: POST /api/v1/auth/logout, userId={}", userId);

        authService.logout(userId);

        return ResponseEntity.ok(ApiResponse.success(null, "ç™»å‡ºæˆåŠŸ"));
    }

    /**
     * è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
     *
     * GET /api/v1/auth/me
     *
     * @param userDetails å½“å‰ç”¨æˆ·
     * @return ç”¨æˆ·ä¿¡æ¯
     */
    @GetMapping("/me")
    public ResponseEntity<ApiResponse<UserResponse>> getCurrentUser(
            @AuthenticationPrincipal CustomUserDetails userDetails
    ) {
        UUID userId = userDetails.getUser().getId();
        log.debug("APIè¯·æ±‚: GET /api/v1/auth/me, userId={}", userId);

        UserResponse user = userService.getUserById(userId);

        return ResponseEntity.ok(ApiResponse.success(user, "è·å–ç”¨æˆ·ä¿¡æ¯æˆåŠŸ"));
    }

    /**
     * è·å–å®¢æˆ·ç«¯IPåœ°å€
     *
     * @param request HTTPè¯·æ±‚
     * @return IPåœ°å€
     */
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }

        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }

        return request.getRemoteAddr();
    }
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ³¨å†ŒAPIæµ‹è¯•é€šè¿‡
- [ ] ç™»å½•APIæµ‹è¯•é€šè¿‡
- [ ] Tokenåˆ·æ–°APIæµ‹è¯•é€šè¿‡
- [ ] ç™»å‡ºAPIæµ‹è¯•é€šè¿‡
- [ ] è·å–å½“å‰ç”¨æˆ·APIæµ‹è¯•é€šè¿‡
- [ ] é‚®ç®±/ç”¨æˆ·åå”¯ä¸€æ€§éªŒè¯æ­£ç¡®
- [ ] å¯†ç åŠ å¯†æ­£ç¡®
- [ ] IPåœ°å€è®°å½•æ­£ç¡®
- [ ] å¤±è´¥ç™»å½•æ¬¡æ•°ç»Ÿè®¡æ­£ç¡®
- [ ] è´¦å·é”å®šæœºåˆ¶æ­£å¸¸

### 1.3.4 Pythonåç«¯

> **è¯´æ˜**: Python AI æœåŠ¡ä¸ç›´æ¥å¤„ç†ç™»å½•æ³¨å†Œï¼Œä½†å¯ä»¥è®°å½•AIæ“ä½œçš„ç”¨æˆ·è®¤è¯æ—¥å¿—ã€‚

**éªŒè¯æ ‡å‡†**:
- [ ] PythonæœåŠ¡èƒ½å¤ŸéªŒè¯JWT Token
- [ ] å®¡è®¡æ—¥å¿—è®°å½•ç”¨æˆ·ç™»å½•çŠ¶æ€

### 1.3.5 éƒ¨ç½²

#### å‰ç«¯è·¯ç”±é…ç½®

```typescript
// frontend/src/routes.tsx
import { Routes, Route } from 'react-router-dom';
import LoginPage from '@/pages/Auth/Login';
import RegisterPage from '@/pages/Auth/Register';
import Dashboard from '@/pages/Dashboard';
import PrivateRoute from '@/components/PrivateRoute';

const AppRoutes = () => {
  return (
    <Routes>
      {/* å…¬å¼€è·¯ç”± */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />

      {/* å—ä¿æŠ¤è·¯ç”± */}
      <Route
        path="/dashboard"
        element={
          <PrivateRoute>
            <Dashboard />
          </PrivateRoute>
        }
      />

      {/* é»˜è®¤é‡å®šå‘ */}
      <Route path="/" element={<Navigate to="/dashboard" />} />
    </Routes>
  );
};
```

**éªŒè¯æ ‡å‡†**:
- [ ] è·¯ç”±é…ç½®æ­£ç¡®
- [ ] æœªç™»å½•è®¿é—®å—ä¿æŠ¤è·¯ç”±è‡ªåŠ¨è·³è½¬ç™»å½•é¡µ
- [ ] ç™»å½•åæ­£ç¡®è·³è½¬åˆ°å·¥ä½œå°

### å­ä»»åŠ¡æ€»ç»“

#### å®Œæˆæ ‡å‡†

**1.3 ç™»å½•æ³¨å†ŒåŠŸèƒ½** è¢«è®¤ä¸ºå®Œæˆéœ€è¦æ»¡è¶³ï¼š

1. **æ•°æ®å®šä¹‰** (100%)
   - [ ] DTO ç±»å®šä¹‰å®Œæ•´
   - [ ] éªŒè¯æ³¨è§£æ­£ç¡®

2. **å‰ç«¯** (100%)
   - [ ] ç™»å½•é¡µé¢æ­£å¸¸
   - [ ] æ³¨å†Œé¡µé¢æ­£å¸¸
   - [ ] è¡¨å•éªŒè¯æ­£ç¡®
   - [ ] APIè°ƒç”¨æˆåŠŸ

3. **Javaåç«¯** (100%)
   - [ ] æ‰€æœ‰APIæµ‹è¯•é€šè¿‡
   - [ ] å®‰å…¨æœºåˆ¶æ­£å¸¸ï¼ˆå¯†ç åŠ å¯†ã€è´¦å·é”å®šï¼‰
   - [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡>80%

4. **Pythonåç«¯** (100%)
   - [ ] TokenéªŒè¯æ­£å¸¸

5. **éƒ¨ç½²** (100%)
   - [ ] è·¯ç”±é…ç½®æ­£ç¡®
   - [ ] æƒé™æ§åˆ¶æ­£å¸¸

---


---

**ğŸ“– ç»§ç»­é˜…è¯»**: [Part2 - å­ä»»åŠ¡ 1.4: æƒé™æ§åˆ¶](./task-plan-java-è¯¦ç»†-JAVA-001-Part2.md)
