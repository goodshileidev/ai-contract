# Python FastAPI AI 服务任务详细计划 - AI-004 - AI-004: 智能匹配分析 - 二级任务 4.1: 需求匹配分析

**工作量估算**: 5 人天
**优先级**: P1 - 高优先级（核心功能）
**技术难点**:
- 多维度匹配算法设计
- 匹配度评分准确性
- 可视化矩阵展示

#### 1) 数据定义

##### Pydantic模型
```python
# app/models/matching.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from decimal import Decimal

class RequirementMatch(BaseModel):
    """需求匹配模型"""
    requirement_id: str = Field(..., description="需求ID")
    requirement_title: str = Field(..., description="需求标题")
    requirement_type: str = Field(..., description="技术/商务/合规")
    is_mandatory: bool = Field(..., description="是否强制要求")
    score_weight: Decimal = Field(..., description="评分权重")

    # 匹配的能力
    matched_capabilities: List[Dict[str, Any]] = Field(default_factory=list, description="匹配的能力列表")

    # 匹配度评分
    match_score: Decimal = Field(..., ge=0, le=100, description="匹配度分数 (0-100)")
    match_status: str = Field(..., description="matched|partial|unmatched")

    # 匹配详情
    match_method: str = Field(..., description="vector|keyword|hybrid")
    vector_similarity: Optional[Decimal] = Field(None, description="向量相似度")
    keyword_coverage: Optional[Decimal] = Field(None, description="关键词覆盖率")

    # 建议
    suggestions: List[str] = Field(default_factory=list, description="改进建议")
    gap_analysis: Optional[str] = Field(None, description="差距分析")

class MatchingMatrix(BaseModel):
    """匹配矩阵"""
    project_id: str = Field(..., description="项目ID")
    organization_id: str = Field(..., description="组织ID")

    # 需求列表
    requirements: List[RequirementMatch] = Field(default_factory=list)

    # 整体匹配度
    overall_match_score: Decimal = Field(..., description="整体匹配度")
    mandatory_match_rate: Decimal = Field(..., description="强制需求匹配率")
    optional_match_rate: Decimal = Field(..., description="可选需求匹配率")

    # 统计信息
    total_requirements: int = Field(..., description="总需求数")
    matched_count: int = Field(..., description="完全匹配数")
    partial_count: int = Field(..., description="部分匹配数")
    unmatched_count: int = Field(..., description="未匹配数")

    # 生成时间
    generated_at: datetime = Field(default_factory=datetime.utcnow)

class MatchingRequest(BaseModel):
    """匹配分析请求"""
    project_id: str = Field(..., description="项目ID")
    organization_id: str = Field(..., description="组织ID")
    match_threshold: Decimal = Field(0.6, ge=0, le=1, description="匹配阈值")
    include_partial: bool = Field(True, description="是否包含部分匹配")
```

##### Java实体
```java
// MatchingResult.java
@Data
@TableName("matching_results")
public class MatchingResult {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;

    private String projectId;
    private String organizationId;

    // 匹配度统计
    private BigDecimal overallMatchScore;
    private BigDecimal mandatoryMatchRate;
    private BigDecimal optionalMatchRate;

    // 需求统计
    private Integer totalRequirements;
    private Integer matchedCount;
    private Integer partialCount;
    private Integer unmatchedCount;

    // 匹配详情（JSONB）
    @TableField(typeHandler = JacksonTypeHandler.class)
    private List<RequirementMatchDetail> matchDetails;

    // 建议（JSONB）
    @TableField(typeHandler = JacksonTypeHandler.class)
    private List<String> recommendations;

    private LocalDateTime generatedAt;
    private LocalDateTime createdAt;
}
```

##### 数据库表
```sql
CREATE TABLE matching_results (
    id UUID PRIMARY KEY,
    project_id UUID NOT NULL,
    organization_id UUID NOT NULL,

    -- 匹配度统计
    overall_match_score DECIMAL(5,2) NOT NULL,  -- 0-100
    mandatory_match_rate DECIMAL(5,2),
    optional_match_rate DECIMAL(5,2),

    -- 需求统计
    total_requirements INTEGER NOT NULL,
    matched_count INTEGER DEFAULT 0,
    partial_count INTEGER DEFAULT 0,
    unmatched_count INTEGER DEFAULT 0,

    -- 匹配详情和建议（JSONB）
    match_details JSONB,
    recommendations JSONB,

    generated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE
);

CREATE INDEX idx_matching_results_project ON matching_results(project_id);
CREATE INDEX idx_matching_results_score ON matching_results(overall_match_score DESC);
```

**验证标准**:
- [ ] Pydantic模型验证通过
- [ ] 评分范围校验正确 (0-100)
- [ ] 数据库表创建成功

#### 2) 前端

```typescript
// src/components/Matching/MatchingMatrix.tsx
import { Card, Progress, Tag, Descriptions, Table, Space } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, ExclamationCircleOutlined } from '@ant-design/icons';
import { useState, useEffect } from 'react';

interface MatchingMatrixProps {
  projectId: string;
}

export default function MatchingMatrix({ projectId }: MatchingMatrixProps) {
  const [matchingData, setMatchingData] = useState<MatchingMatrix | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchMatchingData();
  }, [projectId]);

  const fetchMatchingData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`http://localhost:8001/api/v1/ai/match/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ project_id: projectId })
      });
      const result = await response.json();
      setMatchingData(result.data);
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: '需求',
      dataIndex: 'requirementTitle',
      width: 250,
      render: (text: string, record: RequirementMatch) => (
        <Space>
          {record.isMandatory && <Tag color="red">强制</Tag>}
          <span>{text}</span>
        </Space>
      ),
    },
    {
      title: '类型',
      dataIndex: 'requirementType',
      width: 100,
      render: (type: string) => {
        const colorMap: Record<string, string> = {
          technical: 'blue',
          business: 'green',
          compliance: 'orange',
        };
        return <Tag color={colorMap[type]}>{type}</Tag>;
      },
    },
    {
      title: '匹配度',
      dataIndex: 'matchScore',
      width: 150,
      render: (score: number, record: RequirementMatch) => {
        let status: 'success' | 'exception' | 'normal' = 'normal';
        let color = 'blue';

        if (score >= 80) {
          status = 'success';
          color = 'green';
        } else if (score < 60) {
          status = 'exception';
          color = 'red';
        }

        return (
          <Space>
            <Progress
              type="circle"
              percent={score}
              width={60}
              status={status}
              strokeColor={color}
            />
            <span>{score.toFixed(1)}%</span>
          </Space>
        );
      },
    },
    {
      title: '匹配状态',
      dataIndex: 'matchStatus',
      width: 120,
      render: (status: string) => {
        const statusMap = {
          matched: { icon: <CheckCircleOutlined />, color: 'success', text: '已匹配' },
          partial: { icon: <ExclamationCircleOutlined />, color: 'warning', text: '部分匹配' },
          unmatched: { icon: <CloseCircleOutlined />, color: 'error', text: '未匹配' },
        };
        const config = statusMap[status as keyof typeof statusMap];
        return (
          <Tag icon={config.icon} color={config.color}>
            {config.text}
          </Tag>
        );
      },
    },
    {
      title: '匹配能力',
      dataIndex: 'matchedCapabilities',
      width: 200,
      render: (capabilities: any[]) => (
        <Space direction="vertical" size="small">
          {capabilities.slice(0, 3).map((cap, idx) => (
            <Tag key={idx}>{cap.name} ({(cap.score * 100).toFixed(0)}%)</Tag>
          ))}
          {capabilities.length > 3 && <Tag>+{capabilities.length - 3} more</Tag>}
        </Space>
      ),
    },
    {
      title: '权重',
      dataIndex: 'scoreWeight',
      width: 80,
      render: (weight: number) => `${(weight * 100).toFixed(0)}%`,
    },
    {
      title: '建议',
      dataIndex: 'suggestions',
      width: 200,
      render: (suggestions: string[]) => (
        <ul style={{ paddingLeft: 20, margin: 0 }}>
          {suggestions.map((s, idx) => (
            <li key={idx}>{s}</li>
          ))}
        </ul>
      ),
    },
  ];

  if (loading) {
    return <Card loading />;
  }

  if (!matchingData) {
    return <Card>暂无匹配数据</Card>;
  }

  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      {/* 整体匹配度概览 */}
      <Card title="整体匹配度">
        <Descriptions column={4}>
          <Descriptions.Item label="总体匹配度">
            <Progress
              type="dashboard"
              percent={matchingData.overallMatchScore}
              strokeColor={{
                '0%': '#108ee9',
                '100%': '#87d068',
              }}
            />
          </Descriptions.Item>
          <Descriptions.Item label="强制需求匹配率">
            <Progress
              percent={matchingData.mandatoryMatchRate}
              status={matchingData.mandatoryMatchRate >= 90 ? 'success' : 'exception'}
            />
          </Descriptions.Item>
          <Descriptions.Item label="可选需求匹配率">
            <Progress
              percent={matchingData.optionalMatchRate}
            />
          </Descriptions.Item>
          <Descriptions.Item label="需求统计">
            <Space>
              <Tag color="success">{matchingData.matchedCount} 已匹配</Tag>
              <Tag color="warning">{matchingData.partialCount} 部分</Tag>
              <Tag color="error">{matchingData.unmatchedCount} 未匹配</Tag>
            </Space>
          </Descriptions.Item>
        </Descriptions>
      </Card>

      {/* 详细匹配矩阵 */}
      <Card title="需求匹配明细">
        <Table
          dataSource={matchingData.requirements}
          columns={columns}
          rowKey="requirementId"
          pagination={false}
          scroll={{ x: 1200 }}
          rowClassName={(record) => {
            if (record.matchStatus === 'unmatched') return 'row-unmatched';
            if (record.matchStatus === 'partial') return 'row-partial';
            return 'row-matched';
          }}
        />
      </Card>
    </Space>
  );
}
```

**验证标准**:
- [ ] 匹配矩阵可视化展示正确
- [ ] 进度条颜色根据分数动态变化
- [ ] 表格行样式根据匹配状态变化


#### 3) Java后端

```java
@Service
@RequiredArgsConstructor
public class MatchingService {

    private final RestTemplate restTemplate;
    private final MatchingResultMapper matchingResultMapper;

    /**
     * 触发匹配分析
     * 需求编号: REQ-AI-004
     */
    public MatchingResult triggerMatching(String projectId) {
        log.info("Triggering matching analysis for project: {}", projectId);

        // 调用Python AI服务执行匹配分析
        String pythonAiUrl = "http://backend-python:8001/api/v1/ai/match/analyze";

        MatchingRequest request = MatchingRequest.builder()
            .projectId(projectId)
            .matchThreshold(0.6)
            .includePartial(true)
            .build();

        ResponseEntity<ApiResponse<MatchingMatrix>> response = restTemplate.postForEntity(
            pythonAiUrl,
            request,
            new ParameterizedTypeReference<ApiResponse<MatchingMatrix>>() {}
        );

        MatchingMatrix matrix = response.getBody().getData();

        // 保存匹配结果到数据库
        MatchingResult result = new MatchingResult();
        result.setProjectId(projectId);
        result.setOrganizationId(matrix.getOrganizationId());
        result.setOverallMatchScore(matrix.getOverallMatchScore());
        result.setMandatoryMatchRate(matrix.getMandatoryMatchRate());
        result.setOptionalMatchRate(matrix.getOptionalMatchRate());
        result.setTotalRequirements(matrix.getTotalRequirements());
        result.setMatchedCount(matrix.getMatchedCount());
        result.setPartialCount(matrix.getPartialCount());
        result.setUnmatchedCount(matrix.getUnmatchedCount());
        result.setMatchDetails(convertMatchDetails(matrix.getRequirements()));
        result.setGeneratedAt(LocalDateTime.now());

        matchingResultMapper.insert(result);

        return result;
    }

    /**
     * 获取匹配结果
     */
    public MatchingResult getMatchingResult(String projectId) {
        return matchingResultMapper.selectOne(
            new QueryWrapper<MatchingResult>()
                .eq("project_id", projectId)
                .orderByDesc("generated_at")
                .last("LIMIT 1")
        );
    }
}
```

**验证标准**:
- [ ] 能成功调用Python AI服务
- [ ] 匹配结果能正确保存到数据库
- [ ] 查询最新匹配结果功能正常

#### 4) Python后端

##### 匹配分析服务
```python
# app/services/ai/matching_service.py
from typing import List, Dict, Any
from app.models.matching import MatchingRequest, MatchingMatrix, RequirementMatch
from app.services.ai.hybrid_search_service import HybridSearchService
from app.services.ai.embedding_service import EmbeddingService
from decimal import Decimal
import httpx
import logging

logger = logging.getLogger(__name__)

class MatchingService:
    """智能匹配分析服务
    需求编号: REQ-AI-004
    """

    def __init__(self):
        self.search_service = HybridSearchService()
        self.embedding_service = EmbeddingService()
        self.java_client = httpx.AsyncClient(base_url="http://backend-java:8080")

    async def analyze_matching(self, request: MatchingRequest) -> MatchingMatrix:
        """
        执行需求匹配分析

        Args:
            request: 匹配分析请求

        Returns:
            匹配矩阵
        """
        logger.info(f"Analyzing matching for project: {request.project_id}")

        # 1. 从Java服务获取项目需求
        requirements = await self._fetch_requirements(request.project_id)

        # 2. 对每个需求进行匹配分析
        requirement_matches = []
        for req in requirements:
            match_result = await self._match_single_requirement(
                requirement=req,
                organization_id=request.organization_id,
                threshold=request.match_threshold
            )
            requirement_matches.append(match_result)

        # 3. 计算整体匹配度
        overall_stats = self._calculate_overall_stats(requirement_matches)

        # 4. 构建匹配矩阵
        matrix = MatchingMatrix(
            project_id=request.project_id,
            organization_id=request.organization_id,
            requirements=requirement_matches,
            overall_match_score=Decimal(overall_stats['overall_score']),
            mandatory_match_rate=Decimal(overall_stats['mandatory_rate']),
            optional_match_rate=Decimal(overall_stats['optional_rate']),
            total_requirements=len(requirements),
            matched_count=overall_stats['matched_count'],
            partial_count=overall_stats['partial_count'],
            unmatched_count=overall_stats['unmatched_count']
        )

        logger.info(f"Matching analysis completed. Overall score: {matrix.overall_match_score}")

        return matrix

    async def _fetch_requirements(self, project_id: str) -> List[Dict[str, Any]]:
        """从Java服务获取项目需求"""
        response = await self.java_client.get(
            f"/api/v1/projects/{project_id}/requirements"
        )
        response.raise_for_status()
        return response.json()['data']

    async def _match_single_requirement(
        self,
        requirement: Dict[str, Any],
        organization_id: str,
        threshold: Decimal
    ) -> RequirementMatch:
        """
        匹配单个需求

        策略:
        1. 向量检索（语义相似度，权重60%）
        2. 关键词检索（精确匹配，权重40%）
        3. 综合评分
        """
        req_text = f"{requirement['title']}: {requirement['description']}"

        # 执行混合检索
        from app.models.search import SearchRequest, SearchMode
        search_request = SearchRequest(
            query=req_text,
            organization_id=organization_id,
            search_mode=SearchMode.HYBRID,
            vector_weight=0.6,
            keyword_weight=0.4,
            enable_rerank=True,
            top_k=10
        )

        search_response = await self.search_service.search(search_request)

        # 提取匹配的能力
        matched_capabilities = []
        for result in search_response.results:
            matched_capabilities.append({
                'capability_id': result.capability_id,
                'capability_type': result.capability_type,
                'name': result.name,
                'score': float(result.relevance_score),
                'vector_score': float(result.vector_score) if result.vector_score else None,
                'keyword_score': float(result.keyword_score) if result.keyword_score else None,
            })

        # 计算匹配度
        if matched_capabilities:
            # 使用最佳匹配的分数
            best_score = matched_capabilities[0]['score'] * 100
            match_score = Decimal(best_score).quantize(Decimal('0.01'))

            # 判断匹配状态
            if match_score >= 80:
                match_status = "matched"
            elif match_score >= float(threshold) * 100:
                match_status = "partial"
            else:
                match_status = "unmatched"
        else:
            match_score = Decimal(0)
            match_status = "unmatched"

        # 生成改进建议
        suggestions = self._generate_suggestions(
            requirement=requirement,
            match_score=match_score,
            matched_capabilities=matched_capabilities
        )

        return RequirementMatch(
            requirement_id=requirement['id'],
            requirement_title=requirement['title'],
            requirement_type=requirement.get('requirement_type', 'technical'),
            is_mandatory=requirement.get('is_mandatory', False),
            score_weight=Decimal(requirement.get('score_weight', 1.0)),
            matched_capabilities=matched_capabilities,
            match_score=match_score,
            match_status=match_status,
            match_method="hybrid",
            vector_similarity=Decimal(matched_capabilities[0]['vector_score']) if matched_capabilities else None,
            keyword_coverage=Decimal(matched_capabilities[0]['keyword_score']) if matched_capabilities else None,
            suggestions=suggestions
        )

    def _calculate_overall_stats(
        self,
        requirement_matches: List[RequirementMatch]
    ) -> Dict[str, Any]:
        """计算整体匹配统计"""
        total = len(requirement_matches)
        matched_count = sum(1 for m in requirement_matches if m.match_status == 'matched')
        partial_count = sum(1 for m in requirement_matches if m.match_status == 'partial')
        unmatched_count = sum(1 for m in requirement_matches if m.match_status == 'unmatched')

        # 加权平均分数
        total_weighted_score = sum(
            float(m.match_score) * float(m.score_weight)
            for m in requirement_matches
        )
        total_weight = sum(float(m.score_weight) for m in requirement_matches)
        overall_score = total_weighted_score / total_weight if total_weight > 0 else 0

        # 强制需求匹配率
        mandatory_matches = [m for m in requirement_matches if m.is_mandatory]
        if mandatory_matches:
            mandatory_matched = sum(
                1 for m in mandatory_matches
                if m.match_status in ['matched', 'partial']
            )
            mandatory_rate = (mandatory_matched / len(mandatory_matches)) * 100
        else:
            mandatory_rate = 100

        # 可选需求匹配率
        optional_matches = [m for m in requirement_matches if not m.is_mandatory]
        if optional_matches:
            optional_matched = sum(
                1 for m in optional_matches
                if m.match_status in ['matched', 'partial']
            )
            optional_rate = (optional_matched / len(optional_matches)) * 100
        else:
            optional_rate = 100

        return {
            'overall_score': round(overall_score, 2),
            'mandatory_rate': round(mandatory_rate, 2),
            'optional_rate': round(optional_rate, 2),
            'matched_count': matched_count,
            'partial_count': partial_count,
            'unmatched_count': unmatched_count
        }

    def _generate_suggestions(
        self,
        requirement: Dict[str, Any],
        match_score: Decimal,
        matched_capabilities: List[Dict[str, Any]]
    ) -> List[str]:
        """生成改进建议"""
        suggestions = []

        if match_score < 60:
            suggestions.append("建议补充相关能力或案例")
            if not matched_capabilities:
                suggestions.append("未找到匹配能力，建议添加相关产品或服务")
        elif match_score < 80:
            suggestions.append("存在部分匹配，建议完善现有能力描述")
            if matched_capabilities:
                best_match = matched_capabilities[0]
                suggestions.append(f"可强化 '{best_match['name']}' 的相关特性")

        if requirement.get('is_mandatory') and match_score < 90:
            suggestions.append("⚠️ 强制需求，建议重点关注")

        return suggestions

    async def close(self):
        """关闭资源"""
        await self.java_client.aclose()
```

##### API接口
```python
# app/api/v1/matching.py
from fastapi import APIRouter, HTTPException
from app.models.matching import MatchingRequest, MatchingMatrix
from app.services.ai.matching_service import MatchingService

router = APIRouter(prefix="/match", tags=["匹配分析"])

matching_service = MatchingService()

@router.post("/analyze", response_model=MatchingMatrix)
async def analyze_matching(request: MatchingRequest):
    """
    需求匹配分析
    需求编号: REQ-AI-004

    分析招标需求与企业能力的匹配情况，生成匹配矩阵
    """
    try:
        matrix = await matching_service.analyze_matching(request)
        return matrix
    except Exception as e:
        logger.error(f"Matching analysis failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

**验证标准**:
- [ ] 混合检索算法正确执行
- [ ] 匹配度评分准确（0-100）
- [ ] 强制/可选需求分别统计正确
- [ ] 改进建议生成合理

#### 5) 部署

```yaml
# docker-compose.yml
services:
  matching-worker:
    build: ./backend-python
    command: celery -A app.tasks.celery_app worker --loglevel=info -Q matching
    environment:
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - JAVA_SERVICE_URL=http://backend-java:8080
```

**验证标准**:
- [ ] Worker正常启动
- [ ] 能处理匹配分析任务

---
