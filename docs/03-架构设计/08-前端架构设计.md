---
doc_type: Design
req_id: ARCH-2025-11-010
created_at: 2025-11-30
author: claude-opus-4-1-20250805
updated_at: 2025-11-30 10:00
updater: claude-opus-4-1-20250805
status: 已批准
---

# 前端架构设计

## 概述

本文档描述 AIBidComposer 平台的前端架构设计，采用业界成熟的架构模式和最佳实践。

## 一、整体架构

### 1.1 技术栈选型

```yaml
核心框架:
  框架: React 18.2+
  语言: TypeScript 5.0+
  构建工具: Vite 4.0+

UI组件:
  组件库: Ant Design Pro 6.x
  基础组件: Ant Design 5.0+
  编辑器: Blacknode
  图标: Ant Design Icons
  图表: Recharts + D3.js

状态管理:
  服务端状态: TanStack Query v4（React Query）
  客户端状态: Zustand
  表单状态: Ant Design Form

路由:
  路由: React Router 6

工具库:
  HTTP客户端: axios + 拦截器
  日期处理: date-fns
  工具函数: lodash-es
  文件处理: react-dropzone
  拖拽: @dnd-kit/core
```

### 1.2 项目结构（特性驱动）

```
frontend/
├── src/
│   ├── features/           # 特性模块（核心）
│   │   ├── auth/          # 认证授权
│   │   ├── projects/      # 项目管理
│   │   ├── documents/     # 文档编辑
│   │   ├── templates/     # 模板管理
│   │   ├── ai/           # AI 功能
│   │   ├── variables/     # 变量系统
│   │   ├── tasks/        # 任务管理
│   │   └── capabilities/ # 企业能力
│   ├── services/         # API 服务层
│   ├── components/       # 共享组件
│   ├── hooks/           # 自定义 Hook
│   ├── types/           # TypeScript 类型
│   ├── utils/           # 工具函数
│   ├── styles/          # 全局样式
│   ├── i18n/            # 国际化
│   └── config/          # 配置文件
├── public/              # 静态资源
└── tests/              # 测试文件
```

## 二、核心架构模式

### 2.1 分层架构

```typescript
// 表现层（Presentation Layer）
components/
  ├── pages/          // 页面组件
  ├── layouts/        // 布局组件
  └── ui/            // UI 组件

// 业务逻辑层（Business Logic Layer）
features/
  ├── hooks/         // 业务 Hook
  ├── services/      // 业务服务
  └── stores/       // 状态管理

// 数据访问层（Data Access Layer）
services/
  ├── api/          // API 客户端
  ├── cache/        // 缓存管理
  └── storage/      // 本地存储
```

### 2.2 特性模块架构

每个特性模块的标准结构：

```
features/documents/
├── components/         # 组件
│   ├── DocumentEditor.tsx
│   ├── DocumentList.tsx
│   └── DocumentToolbar.tsx
├── hooks/             # Hook
│   ├── useDocument.ts
│   └── useDocumentSave.ts
├── services/          # 服务
│   ├── documentApi.ts
│   └── documentCache.ts
├── stores/            # 状态
│   └── documentStore.ts
├── types/             # 类型
│   └── document.types.ts
└── index.ts          # 导出
```

## 三、状态管理架构

### 3.1 三层状态管理

```typescript
// 1. 服务端状态 - TanStack Query
const useDocuments = () => {
  return useQuery({
    queryKey: ['documents'],
    queryFn: fetchDocuments,
    staleTime: 5 * 60 * 1000, // 5分钟
    cacheTime: 10 * 60 * 1000, // 10分钟
  });
};

// 2. 客户端状态 - Zustand
interface AppStore {
  user: User | null;
  theme: 'light' | 'dark';
  sidebarCollapsed: boolean;
  setUser: (user: User | null) => void;
  toggleTheme: () => void;
  toggleSidebar: () => void;
}

const useAppStore = create<AppStore>((set) => ({
  user: null,
  theme: 'light',
  sidebarCollapsed: false,
  setUser: (user) => set({ user }),
  toggleTheme: () => set((state) => ({
    theme: state.theme === 'light' ? 'dark' : 'light'
  })),
  toggleSidebar: () => set((state) => ({
    sidebarCollapsed: !state.sidebarCollapsed
  })),
}));

// 3. 表单状态 - Ant Design Form
const [form] = Form.useForm();
```

### 3.2 缓存策略

```typescript
// Query Key 设计
const queryKeys = {
  all: ['documents'] as const,
  lists: () => [...queryKeys.all, 'list'] as const,
  list: (filters: string) => [...queryKeys.lists(), { filters }] as const,
  details: () => [...queryKeys.all, 'detail'] as const,
  detail: (id: string) => [...queryKeys.details(), id] as const,
};

// 智能缓存失效
const useInvalidateDocument = () => {
  const queryClient = useQueryClient();

  return (id: string) => {
    // 失效具体文档
    queryClient.invalidateQueries(queryKeys.detail(id));
    // 失效列表
    queryClient.invalidateQueries(queryKeys.lists());
  };
};
```

## 四、组件设计模式

### 4.1 组件分类

```typescript
// 1. 容器组件（Smart Component）
const DocumentPageContainer = () => {
  const documents = useDocuments();
  const handleSave = useDocumentSave();

  return (
    <DocumentPage
      documents={documents}
      onSave={handleSave}
    />
  );
};

// 2. 展示组件（Dumb Component）
interface DocumentPageProps {
  documents: Document[];
  onSave: (document: Document) => void;
}

const DocumentPage: React.FC<DocumentPageProps> = ({
  documents,
  onSave
}) => {
  return (
    <div className="document-page">
      {/* 纯展示逻辑 */}
    </div>
  );
};

// 3. 复合组件（Compound Component）
const DocumentEditor = {
  Root: DocumentEditorRoot,
  Toolbar: DocumentEditorToolbar,
  Content: DocumentEditorContent,
  Footer: DocumentEditorFooter,
};

// 使用
<DocumentEditor.Root>
  <DocumentEditor.Toolbar />
  <DocumentEditor.Content />
  <DocumentEditor.Footer />
</DocumentEditor.Root>
```

### 4.2 性能优化模式

```typescript
// 1. 组件 Memo 化
const ExpensiveComponent = React.memo(({ data }) => {
  return <ComplexVisualization data={data} />;
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return prevProps.data.id === nextProps.data.id;
});

// 2. 虚拟化长列表
import { VirtualList } from '@tanstack/react-virtual';

const DocumentList = ({ documents }) => {
  const virtualizer = useVirtualizer({
    count: documents.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
  });

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      {virtualizer.getVirtualItems().map((virtualRow) => (
        <DocumentItem key={virtualRow.index} document={documents[virtualRow.index]} />
      ))}
    </div>
  );
};

// 3. 懒加载
const AIAssistant = React.lazy(() => import('./features/ai/AIAssistant'));

<Suspense fallback={<Loading />}>
  <AIAssistant />
</Suspense>
```

## 五、编辑器架构（Blacknode）

### 5.1 编辑器集成

```typescript
// 编辑器配置
interface EditorConfig {
  plugins: Plugin[];
  toolbar: ToolbarConfig;
  variables: VariableConfig;
  ai: AIConfig;
}

// 编辑器组件
const BidDocumentEditor: React.FC = () => {
  const editor = useBlacknodeEditor({
    initialContent: document.content,
    plugins: [
      variablePlugin,
      aiAssistantPlugin,
      collaborationPlugin,
    ],
    onChange: (content) => {
      // 自动保存到草稿
      saveDraft(content);
    },
  });

  return (
    <BlacknodeEditor
      editor={editor}
      toolbar={<CustomToolbar />}
      sidebar={<VariablePanel />}
    />
  );
};
```

### 5.2 变量系统架构

```typescript
// 双维度变量架构

// 维度一：技术实现（三层）
interface VariableImplementation {
  // 模板变量定义
  templateVariables: Map<string, TemplateVariable>;

  // 变量映射规则
  variableMappings: Map<string, VariableMapping>;

  // 实例值存储
  instanceValues: Map<string, any>;
}

// 维度二：业务作用域（四层）
interface VariableScope {
  // 项目级别变量
  projectVariables: Map<string, ProjectVariable>;

  // 任务级别变量
  taskVariables: Map<string, TaskVariable>;

  // 文档级别变量
  documentVariables: Map<string, DocumentVariable>;

  // 章节级别变量
  sectionVariables: Map<string, SectionVariable>;
}

// 完整的变量系统
interface CompleteVariableSystem {
  implementation: VariableImplementation;
  scope: VariableScope;

  // 获取特定作用域的变量值
  getVariableValue(variableName: string, scope: 'project' | 'task' | 'document' | 'section'): any;

  // 设置变量值
  setVariableValue(variableName: string, value: any, scope: 'project' | 'task' | 'document' | 'section'): void;
}

// 变量 Provider
const VariableProvider: React.FC = ({ children }) => {
  const [variables, setVariables] = useState<VariableSystem>();

  const resolveVariable = useCallback((name: string) => {
    // 变量解析逻辑
    return variables?.instanceValues.get(name)
      ?? variables?.templateVariables.get(name)?.defaultValue;
  }, [variables]);

  return (
    <VariableContext.Provider value={{ variables, resolveVariable }}>
      {children}
    </VariableContext.Provider>
  );
};
```

## 六、AI 功能架构

### 6.1 AI 服务层

```typescript
// AI 服务抽象
interface AIService {
  process(type: AIProcessingType, input: AIInput): Promise<AIOutput>;
  cancel(taskId: string): void;
  getProgress(taskId: string): number;
}

// AI 处理类型
enum AIProcessingType {
  VariableExtraction = 'variableExtraction',
  TextExpansion = 'textExpansion',
  TextSummary = 'textSummary',
  TextTransformation = 'textTransformation',
  ComplianceReview = 'complianceReview',
  RequirementAnalysis = 'requirementAnalysis',
  ScorePointGeneration = 'scorePointGeneration',
}

// AI Hook
const useAI = () => {
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState(0);

  const process = useCallback(async (type: AIProcessingType, input: any) => {
    setLoading(true);
    try {
      const result = await aiService.process(type, input);
      return result;
    } finally {
      setLoading(false);
    }
  }, []);

  return { process, loading, progress };
};
```

### 6.2 AI 集成模式

```typescript
// 编辑器 AI 集成
const AIEnhancedEditor = () => {
  const { process } = useAI();
  const editor = useEditor();

  const handleAICommand = async (command: string) => {
    const selection = editor.getSelection();
    const result = await process(AIProcessingType.TextExpansion, {
      text: selection,
      command,
    });
    editor.replaceSelection(result.text);
  };

  return (
    <EditorWithAI
      onAICommand={handleAICommand}
      aiCommands={['扩展', '总结', '改写', '检查']}
    />
  );
};
```

## 七、性能优化架构

### 7.1 代码分割策略

```typescript
// 路由级分割
const routes = [
  {
    path: '/projects',
    component: lazy(() => import('./features/projects/ProjectPage')),
  },
  {
    path: '/documents',
    component: lazy(() => import('./features/documents/DocumentPage')),
  },
  {
    path: '/ai',
    component: lazy(() => import('./features/ai/AIAssistantPage')),
  },
];

// 功能级分割
const loadAIFeature = () => import('./features/ai');
const loadTemplateFeature = () => import('./features/templates');
```

### 7.2 资源优化

```typescript
// 图片懒加载
const LazyImage: React.FC<{ src: string }> = ({ src }) => {
  const [imageSrc, setImageSrc] = useState<string>();
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, [src]);

  return <img ref={imgRef} src={imageSrc} />;
};

// 防抖和节流
const debouncedSearch = useMemo(
  () => debounce((value: string) => {
    search(value);
  }, 300),
  []
);
```

## 八、错误处理架构

### 8.1 错误边界

```typescript
class ErrorBoundary extends React.Component<Props, State> {
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // 记录错误
    logger.error('React Error Boundary', { error, errorInfo });

    // 上报错误
    errorReporter.report(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback onReset={() => this.setState({ hasError: false })} />;
    }

    return this.props.children;
  }
}
```

### 8.2 全局错误处理

```typescript
// API 错误处理
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 认证失败
      authStore.logout();
    } else if (error.response?.status === 403) {
      // 权限不足
      message.error('您没有权限执行此操作');
    } else if (error.response?.status >= 500) {
      // 服务器错误
      message.error('服务器错误，请稍后重试');
    }

    return Promise.reject(error);
  }
);
```

## 九、测试架构

### 9.1 测试策略

```typescript
// 单元测试 - Vitest
describe('DocumentEditor', () => {
  it('should render editor', () => {
    const { container } = render(<DocumentEditor />);
    expect(container).toBeInTheDocument();
  });

  it('should save document on Ctrl+S', async () => {
    const onSave = vi.fn();
    render(<DocumentEditor onSave={onSave} />);

    fireEvent.keyDown(document, { key: 'S', ctrlKey: true });
    await waitFor(() => expect(onSave).toHaveBeenCalled());
  });
});

// 集成测试
describe('Document Flow', () => {
  it('should create and save document', async () => {
    const { getByRole, getByText } = render(<App />);

    // 创建文档
    fireEvent.click(getByRole('button', { name: '新建文档' }));

    // 编辑内容
    const editor = getByRole('textbox');
    fireEvent.change(editor, { target: { value: '测试内容' } });

    // 保存
    fireEvent.click(getByRole('button', { name: '保存' }));

    // 验证
    await waitFor(() => {
      expect(getByText('保存成功')).toBeInTheDocument();
    });
  });
});
```

## 十、部署架构

### 10.1 构建优化

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom', 'react-router-dom'],
          'antd-vendor': ['antd', '@ant-design/icons', '@ant-design/pro-components'],
          'editor': ['blacknode-editor'],
          'utils': ['lodash-es', 'date-fns', 'axios'],
        },
      },
    },
    chunkSizeWarningLimit: 1000,
  },
  optimizeDeps: {
    include: ['react', 'react-dom', 'antd'],
  },
});
```

### 10.2 环境配置

```typescript
// 环境变量管理
interface EnvConfig {
  VITE_API_BASE_URL: string;
  VITE_AI_SERVICE_URL: string;
  VITE_WS_URL: string;
  VITE_STORAGE_URL: string;
}

const getEnvConfig = (): EnvConfig => {
  return {
    VITE_API_BASE_URL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080',
    VITE_AI_SERVICE_URL: import.meta.env.VITE_AI_SERVICE_URL || 'http://localhost:8001',
    VITE_WS_URL: import.meta.env.VITE_WS_URL || 'ws://localhost:8080',
    VITE_STORAGE_URL: import.meta.env.VITE_STORAGE_URL || 'http://localhost:9000',
  };
};
```

## 关键收益

通过复用 aidev3 的前端架构，我们获得：

1. **成熟的架构模式** - 经过验证的分层架构和模块设计
2. **优秀的状态管理** - 三层状态管理清晰高效
3. **完整的组件体系** - 可复用的组件和 Hook
4. **强大的编辑器** - Blacknode 编辑器完美适配
5. **灵活的 AI 集成** - 易于扩展的 AI 架构
6. **优化的性能** - 完善的性能优化策略

---

## 修改历史

| 日期 | 版本 | 修改者 | 修改内容概要 |
|------|------|--------|-------------|
| 2025-11-30 09:45 | 1.0 | claude-opus-4-1-20250805 | 创建前端架构设计文档 |

---

**文档状态**: ✅ 已批准
**下一步**: 更新业务设计文档