---
文档类型: 实现文档
需求编号: REQ-2025-11-004
创建日期: 2025-11-30 12:45
创建者: claude-opus-4-1-20250805
最后更新: 2025-11-30 12:45
更新者: claude-opus-4-1-20250805
状态: 实现中
---

# 智能内容生成算法 - Python实现代码

## 1. 项目结构

```
content_generation/
├── __init__.py
├── core/
│   ├── __init__.py
│   ├── content_planner.py      # 内容规划引擎
│   ├── knowledge_fusion.py     # 知识融合引擎
│   ├── template_matcher.py     # 模板匹配引擎
│   └── generator.py            # 多模型生成器
├── models/
│   ├── __init__.py
│   ├── llm_wrapper.py         # 大模型封装
│   └── prompt_manager.py      # Prompt管理
├── utils/
│   ├── __init__.py
│   ├── cache.py              # 缓存工具
│   └── validators.py         # 验证工具
└── config.py                  # 配置文件
```

## 2. 核心实现代码

### 2.1 内容规划引擎

```python
# content_generation/core/content_planner.py

import re
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class ContentPlan:
    """内容规划数据结构"""
    project_id: str
    sections: List[Dict[str, Any]]
    word_count: int
    generation_strategy: str
    metadata: Dict[str, Any]

class ContentPlanningEngine:
    """内容规划引擎"""

    def __init__(self):
        self.section_patterns = {
            'technical_solution': {
                'weight': 0.3,
                'min_words': 5000,
                'required_elements': ['技术架构', '实施方案', '技术优势']
            },
            'commercial_proposal': {
                'weight': 0.25,
                'min_words': 3000,
                'required_elements': ['报价明细', '付款方式', '商务条款']
            },
            'project_team': {
                'weight': 0.2,
                'min_words': 2000,
                'required_elements': ['团队组成', '人员简历', '项目经验']
            },
            'implementation_plan': {
                'weight': 0.15,
                'min_words': 2000,
                'required_elements': ['时间计划', '里程碑', '交付物']
            },
            'after_service': {
                'weight': 0.1,
                'min_words': 1000,
                'required_elements': ['服务内容', '响应时间', '保障措施']
            }
        }

    def analyze_requirements(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """分析招标需求"""
        logger.info(f"Analyzing requirements for project: {requirements.get('project_id')}")

        analysis = {
            'project_type': self._identify_project_type(requirements),
            'industry': self._identify_industry(requirements),
            'key_requirements': self._extract_key_requirements(requirements),
            'scoring_criteria': self._extract_scoring_criteria(requirements),
            'mandatory_sections': self._identify_mandatory_sections(requirements)
        }

        return analysis

    def create_content_plan(self,
                           requirements: Dict[str, Any],
                           word_limit: int = 50000) -> ContentPlan:
        """创建内容规划"""
        analysis = self.analyze_requirements(requirements)

        # 构建章节结构
        sections = self._build_sections(analysis, word_limit)

        # 确定生成策略
        strategy = self._determine_strategy(analysis)

        plan = ContentPlan(
            project_id=requirements.get('project_id', ''),
            sections=sections,
            word_count=word_limit,
            generation_strategy=strategy,
            metadata={
                'project_type': analysis['project_type'],
                'industry': analysis['industry'],
                'created_at': self._get_timestamp()
            }
        )

        logger.info(f"Content plan created: {len(sections)} sections, {word_limit} words")
        return plan

    def _identify_project_type(self, requirements: Dict[str, Any]) -> str:
        """识别项目类型"""
        content = requirements.get('content', '').lower()

        if any(keyword in content for keyword in ['软件', '系统', '平台', '应用']):
            return 'software'
        elif any(keyword in content for keyword in ['硬件', '设备', '采购']):
            return 'hardware'
        elif any(keyword in content for keyword in ['服务', '咨询', '运维']):
            return 'service'
        else:
            return 'general'

    def _identify_industry(self, requirements: Dict[str, Any]) -> str:
        """识别行业领域"""
        content = requirements.get('content', '').lower()

        industry_keywords = {
            'government': ['政府', '政务', '公共', '行政'],
            'finance': ['金融', '银行', '保险', '证券'],
            'healthcare': ['医疗', '医院', '卫生', '健康'],
            'education': ['教育', '学校', '培训', '高校'],
            'manufacturing': ['制造', '工业', '生产', '工厂'],
            'retail': ['零售', '商业', '电商', '销售'],
            'technology': ['科技', '互联网', 'IT', '信息化']
        }

        for industry, keywords in industry_keywords.items():
            if any(keyword in content for keyword in keywords):
                return industry

        return 'general'

    def _extract_key_requirements(self, requirements: Dict[str, Any]) -> List[str]:
        """提取关键需求"""
        key_requirements = []
        content = requirements.get('content', '')

        # 使用正则表达式提取编号的需求项
        patterns = [
            r'[一二三四五六七八九十]\s*[、.]\s*(.+?)(?=[一二三四五六七八九十]\s*[、.]|$)',
            r'\d+\s*[、.]\s*(.+?)(?=\d+\s*[、.]|$)',
            r'[（(]\d+[）)]\s*(.+?)(?=[（(]\d+[）)]|$)'
        ]

        for pattern in patterns:
            matches = re.findall(pattern, content, re.MULTILINE)
            key_requirements.extend(matches)

        # 去重和清理
        key_requirements = list(set(req.strip() for req in key_requirements if req.strip()))

        return key_requirements[:20]  # 返回前20个关键需求

    def _extract_scoring_criteria(self, requirements: Dict[str, Any]) -> Dict[str, float]:
        """提取评分标准"""
        content = requirements.get('content', '')
        criteria = {}

        # 查找评分相关的模式
        score_patterns = [
            (r'技术[方案分数权重：:\s]*(\d+)', 'technical'),
            (r'商务[报价分数权重：:\s]*(\d+)', 'commercial'),
            (r'服务[方案分数权重：:\s]*(\d+)', 'service'),
            (r'资质[信誉分数权重：:\s]*(\d+)', 'qualification')
        ]

        for pattern, key in score_patterns:
            match = re.search(pattern, content)
            if match:
                criteria[key] = float(match.group(1)) / 100

        # 如果没有找到，使用默认权重
        if not criteria:
            criteria = {
                'technical': 0.4,
                'commercial': 0.3,
                'service': 0.2,
                'qualification': 0.1
            }

        return criteria

    def _identify_mandatory_sections(self, requirements: Dict[str, Any]) -> List[str]:
        """识别必需章节"""
        mandatory = []
        content = requirements.get('content', '')

        section_keywords = {
            '技术方案': ['技术方案', '技术要求', '技术规格'],
            '商务报价': ['报价', '价格', '费用'],
            '实施计划': ['实施', '进度', '工期'],
            '项目团队': ['人员', '团队', '组织'],
            '售后服务': ['售后', '维护', '服务']
        }

        for section, keywords in section_keywords.items():
            if any(keyword in content for keyword in keywords):
                mandatory.append(section)

        return mandatory

    def _build_sections(self, analysis: Dict[str, Any], word_limit: int) -> List[Dict[str, Any]]:
        """构建章节结构"""
        sections = []
        remaining_words = word_limit

        # 优先处理必需章节
        mandatory_sections = analysis.get('mandatory_sections', [])

        for section_type, config in self.section_patterns.items():
            section_name = self._get_section_name(section_type)

            if section_name in mandatory_sections or remaining_words > config['min_words']:
                word_count = min(
                    int(word_limit * config['weight']),
                    remaining_words
                )

                sections.append({
                    'type': section_type,
                    'name': section_name,
                    'word_count': word_count,
                    'weight': config['weight'],
                    'required_elements': config['required_elements'],
                    'priority': 'high' if section_name in mandatory_sections else 'normal'
                })

                remaining_words -= word_count

        return sections

    def _get_section_name(self, section_type: str) -> str:
        """获取章节名称"""
        name_mapping = {
            'technical_solution': '技术方案',
            'commercial_proposal': '商务报价',
            'project_team': '项目团队',
            'implementation_plan': '实施计划',
            'after_service': '售后服务'
        }
        return name_mapping.get(section_type, section_type)

    def _determine_strategy(self, analysis: Dict[str, Any]) -> str:
        """确定生成策略"""
        project_type = analysis.get('project_type', 'general')

        if project_type == 'software':
            return 'technical_focused'
        elif project_type == 'service':
            return 'service_focused'
        else:
            return 'balanced'

    def _get_timestamp(self) -> str:
        """获取时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()
```

### 2.2 知识融合引擎

```python
# content_generation/core/knowledge_fusion.py

import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import logging

logger = logging.getLogger(__name__)

class KnowledgeFusionEngine:
    """知识融合引擎"""

    def __init__(self):
        self.vectorizer = TfidfVectorizer(max_features=5000)
        self.capability_cache = {}

    def match_capabilities(self,
                          requirements: List[str],
                          capabilities: Dict[str, Any]) -> Dict[str, Any]:
        """匹配企业能力"""
        logger.info(f"Matching {len(requirements)} requirements with capabilities")

        matches = {
            'products': self._match_products(requirements, capabilities.get('products', [])),
            'cases': self._match_cases(requirements, capabilities.get('cases', [])),
            'personnel': self._match_personnel(requirements, capabilities.get('personnel', [])),
            'qualifications': self._match_qualifications(requirements, capabilities.get('qualifications', []))
        }

        # 计算整体匹配度
        overall_score = self._calculate_overall_score(matches)
        matches['overall_score'] = overall_score

        return matches

    def _match_products(self,
                       requirements: List[str],
                       products: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """匹配产品服务"""
        if not products:
            return []

        # 构建需求文本
        req_text = ' '.join(requirements)

        # 构建产品文本
        product_texts = []
        for product in products:
            text = f"{product.get('name', '')} {product.get('description', '')} {' '.join(product.get('features', []))}"
            product_texts.append(text)

        # 计算相似度
        if product_texts:
            all_texts = [req_text] + product_texts
            tfidf_matrix = self.vectorizer.fit_transform(all_texts)
            similarities = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:]).flatten()

            # 添加相似度分数
            matched_products = []
            for i, product in enumerate(products):
                if similarities[i] > 0.3:  # 相似度阈值
                    product['match_score'] = float(similarities[i])
                    matched_products.append(product)

            # 排序返回
            matched_products.sort(key=lambda x: x['match_score'], reverse=True)
            return matched_products[:10]  # 返回前10个匹配的产品

        return []

    def _match_cases(self,
                    requirements: List[str],
                    cases: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """匹配项目案例"""
        if not cases:
            return []

        matched_cases = []
        req_keywords = set(' '.join(requirements).lower().split())

        for case in cases:
            # 提取案例关键词
            case_text = f"{case.get('name', '')} {case.get('description', '')} {case.get('industry', '')}"
            case_keywords = set(case_text.lower().split())

            # 计算关键词重合度
            overlap = len(req_keywords & case_keywords)
            if overlap > 0:
                score = overlap / len(req_keywords)
                case['match_score'] = score
                matched_cases.append(case)

        # 排序返回
        matched_cases.sort(key=lambda x: x['match_score'], reverse=True)
        return matched_cases[:5]  # 返回前5个匹配的案例

    def _match_personnel(self,
                        requirements: List[str],
                        personnel: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """匹配人员资质"""
        if not personnel:
            return []

        # 从需求中提取角色关键词
        role_keywords = ['项目经理', '技术负责人', '架构师', '开发工程师', '测试工程师']
        required_roles = []

        req_text = ' '.join(requirements).lower()
        for role in role_keywords:
            if role in req_text:
                required_roles.append(role)

        # 匹配人员
        matched_personnel = []
        for person in personnel:
            person_role = person.get('role', '').lower()
            for required_role in required_roles:
                if required_role in person_role:
                    person['match_role'] = required_role
                    matched_personnel.append(person)
                    break

        return matched_personnel

    def _match_qualifications(self,
                             requirements: List[str],
                             qualifications: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """匹配企业资质"""
        if not qualifications:
            return []

        # 从需求中提取资质关键词
        qual_keywords = ['ISO', 'CMMI', '高新技术', '软件企业', '资质', '认证', '证书']
        required_quals = []

        req_text = ' '.join(requirements)
        for keyword in qual_keywords:
            if keyword in req_text:
                required_quals.append(keyword)

        # 匹配资质
        matched_quals = []
        for qual in qualifications:
            qual_name = qual.get('name', '')
            for required in required_quals:
                if required in qual_name:
                    qual['match_keyword'] = required
                    matched_quals.append(qual)
                    break

        return matched_quals

    def _calculate_overall_score(self, matches: Dict[str, Any]) -> float:
        """计算整体匹配度"""
        scores = []
        weights = {
            'products': 0.3,
            'cases': 0.3,
            'personnel': 0.2,
            'qualifications': 0.2
        }

        for key, weight in weights.items():
            items = matches.get(key, [])
            if items:
                # 计算该类别的平均匹配度
                avg_score = sum(item.get('match_score', 0.5) for item in items) / len(items)
                scores.append(avg_score * weight)
            else:
                scores.append(0)

        return sum(scores)

    def generate_fusion_content(self,
                               section_type: str,
                               matched_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成融合内容"""
        logger.info(f"Generating fusion content for section: {section_type}")

        fusion_content = {
            'section_type': section_type,
            'data_points': [],
            'suggested_content': []
        }

        # 根据章节类型选择融合策略
        if section_type == 'technical_solution':
            fusion_content = self._fuse_technical_content(matched_data)
        elif section_type == 'project_team':
            fusion_content = self._fuse_team_content(matched_data)
        elif section_type == 'project_cases':
            fusion_content = self._fuse_case_content(matched_data)

        return fusion_content

    def _fuse_technical_content(self, matched_data: Dict[str, Any]) -> Dict[str, Any]:
        """融合技术方案内容"""
        products = matched_data.get('products', [])

        content = {
            'section_type': 'technical_solution',
            'data_points': [],
            'suggested_content': []
        }

        # 提取产品特性
        for product in products[:3]:  # 使用前3个匹配的产品
            content['data_points'].append({
                'type': 'product',
                'name': product.get('name'),
                'features': product.get('features', []),
                'advantages': product.get('advantages', [])
            })

            # 生成建议内容
            suggestion = f"我司的{product.get('name')}产品完全满足本项目的技术要求，"
            suggestion += f"具备{'、'.join(product.get('features', [])[:3])}等核心功能。"
            content['suggested_content'].append(suggestion)

        return content

    def _fuse_team_content(self, matched_data: Dict[str, Any]) -> Dict[str, Any]:
        """融合团队内容"""
        personnel = matched_data.get('personnel', [])

        content = {
            'section_type': 'project_team',
            'data_points': [],
            'suggested_content': []
        }

        # 按角色组织团队
        team_by_role = {}
        for person in personnel:
            role = person.get('match_role', '其他')
            if role not in team_by_role:
                team_by_role[role] = []
            team_by_role[role].append(person)

        # 生成团队介绍
        for role, members in team_by_role.items():
            content['data_points'].append({
                'type': 'team',
                'role': role,
                'members': [m.get('name') for m in members],
                'count': len(members)
            })

            if members:
                suggestion = f"本项目{role}由{members[0].get('name')}担任，"
                suggestion += f"具有{members[0].get('experience', 5)}年相关经验。"
                content['suggested_content'].append(suggestion)

        return content

    def _fuse_case_content(self, matched_data: Dict[str, Any]) -> Dict[str, Any]:
        """融合案例内容"""
        cases = matched_data.get('cases', [])

        content = {
            'section_type': 'project_cases',
            'data_points': [],
            'suggested_content': []
        }

        # 选择最相关的案例
        for case in cases[:3]:
            content['data_points'].append({
                'type': 'case',
                'name': case.get('name'),
                'client': case.get('client'),
                'amount': case.get('amount'),
                'duration': case.get('duration')
            })

            # 生成案例描述
            suggestion = f"在{case.get('name')}项目中，我司为{case.get('client')}提供了类似的解决方案，"
            suggestion += f"项目金额{case.get('amount')}万元，获得了客户的高度认可。"
            content['suggested_content'].append(suggestion)

        return content
```

### 2.3 多模型协同生成器

```python
# content_generation/core/generator.py

import asyncio
import json
from typing import Dict, List, Any, Optional
from enum import Enum
import logging
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

class ModelType(Enum):
    """模型类型枚举"""
    GPT4 = "gpt-4"
    GPT35 = "gpt-3.5-turbo"
    CLAUDE = "claude-3"
    CUSTOM = "custom"

class MultiModelGenerator:
    """多模型协同生成器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.model_pool = self._initialize_models()
        self.executor = ThreadPoolExecutor(max_workers=5)

    def _initialize_models(self) -> Dict[str, Any]:
        """初始化模型池"""
        models = {
            ModelType.GPT4: {
                'endpoint': self.config.get('gpt4_endpoint'),
                'api_key': self.config.get('gpt4_api_key'),
                'max_tokens': 4000,
                'temperature': 0.7
            },
            ModelType.GPT35: {
                'endpoint': self.config.get('gpt35_endpoint'),
                'api_key': self.config.get('gpt35_api_key'),
                'max_tokens': 2000,
                'temperature': 0.8
            },
            ModelType.CLAUDE: {
                'endpoint': self.config.get('claude_endpoint'),
                'api_key': self.config.get('claude_api_key'),
                'max_tokens': 8000,
                'temperature': 0.7
            }
        }
        return models

    async def generate_content(self,
                              plan: Dict[str, Any],
                              fusion_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成内容主函数"""
        logger.info(f"Starting content generation for {len(plan['sections'])} sections")

        # 创建生成任务
        tasks = []
        for section in plan['sections']:
            task = self._create_generation_task(section, fusion_data)
            tasks.append(task)

        # 并发执行生成任务
        results = await asyncio.gather(*tasks)

        # 组装最终文档
        document = self._assemble_document(results)

        return document

    async def _create_generation_task(self,
                                     section: Dict[str, Any],
                                     fusion_data: Dict[str, Any]) -> Dict[str, Any]:
        """创建生成任务"""
        # 根据章节类型选择模型
        model_type = self._select_model(section['type'])

        # 构建提示词
        prompt = self._build_prompt(section, fusion_data)

        # 调用模型生成
        content = await self._call_model(model_type, prompt, section['word_count'])

        # 后处理
        processed_content = self._post_process(content, section)

        return {
            'section': section,
            'content': processed_content,
            'metadata': {
                'model': model_type.value,
                'word_count': len(processed_content),
                'quality_score': self._evaluate_quality(processed_content)
            }
        }

    def _select_model(self, section_type: str) -> ModelType:
        """根据章节类型选择模型"""
        model_mapping = {
            'technical_solution': ModelType.GPT4,      # 技术方案用GPT-4
            'commercial_proposal': ModelType.CLAUDE,    # 商务标书用Claude
            'implementation_plan': ModelType.GPT35,     # 实施计划用GPT-3.5
            'project_team': ModelType.GPT35,           # 团队介绍用GPT-3.5
            'after_service': ModelType.GPT35           # 售后服务用GPT-3.5
        }

        return model_mapping.get(section_type, ModelType.GPT35)

    def _build_prompt(self,
                     section: Dict[str, Any],
                     fusion_data: Dict[str, Any]) -> str:
        """构建提示词"""
        # 基础提示词模板
        base_prompt = f"""
        请为投标文档生成{section['name']}章节的内容。

        要求：
        1. 字数要求：约{section['word_count']}字
        2. 必须包含以下要素：{', '.join(section['required_elements'])}
        3. 语言风格：专业、正式、有说服力
        4. 结构清晰，逻辑严谨

        """

        # 添加融合数据
        if fusion_data:
            base_prompt += "\n参考信息：\n"
            for key, value in fusion_data.items():
                if isinstance(value, list) and value:
                    base_prompt += f"- {key}: {value[:3]}\n"  # 只使用前3个

        # 添加章节特定的提示
        section_prompts = {
            'technical_solution': """
            技术方案应重点突出：
            - 技术架构的先进性和可靠性
            - 与需求的匹配度
            - 技术创新点和亮点
            - 风险控制措施
            """,
            'commercial_proposal': """
            商务报价应包含：
            - 详细的报价明细表
            - 价格构成说明
            - 付款方式和条件
            - 优惠政策说明
            """,
            'implementation_plan': """
            实施计划应明确：
            - 项目阶段划分
            - 时间节点安排
            - 关键里程碑
            - 资源配置计划
            """
        }

        base_prompt += section_prompts.get(section['type'], "")

        return base_prompt

    async def _call_model(self,
                         model_type: ModelType,
                         prompt: str,
                         max_length: int) -> str:
        """调用模型生成内容"""
        model_config = self.model_pool.get(model_type)

        if not model_config:
            logger.error(f"Model {model_type} not configured")
            return ""

        try:
            # 这里应该调用实际的API
            # 为了演示，返回模拟内容
            logger.info(f"Calling {model_type.value} model")

            # 模拟异步调用
            await asyncio.sleep(0.5)

            # 实际实现时，这里应该是：
            # response = await self._make_api_call(model_config, prompt, max_length)
            # return response['content']

            # 模拟返回
            return f"[{model_type.value}生成的内容]\n{prompt}\n\n生成的章节内容约{max_length}字..."

        except Exception as e:
            logger.error(f"Error calling model {model_type}: {e}")
            return ""

    def _post_process(self, content: str, section: Dict[str, Any]) -> str:
        """内容后处理"""
        # 格式化
        processed = self._format_content(content)

        # 添加章节标题
        processed = f"# {section['name']}\n\n{processed}"

        # 检查必需元素
        for element in section.get('required_elements', []):
            if element not in processed:
                # 如果缺少必需元素，添加占位符
                processed += f"\n\n## {element}\n\n[待补充{element}内容]"

        # 调整字数
        if len(processed) < section['word_count'] * 0.8:
            # 字数不足，需要扩充
            processed = self._expand_content(processed, section['word_count'])
        elif len(processed) > section['word_count'] * 1.2:
            # 字数过多，需要精简
            processed = self._compress_content(processed, section['word_count'])

        return processed

    def _format_content(self, content: str) -> str:
        """格式化内容"""
        # 清理多余的空行
        lines = content.split('\n')
        formatted_lines = []

        for line in lines:
            line = line.strip()
            if line:
                formatted_lines.append(line)
            elif formatted_lines and formatted_lines[-1]:
                formatted_lines.append('')  # 保留一个空行

        return '\n'.join(formatted_lines)

    def _expand_content(self, content: str, target_length: int) -> str:
        """扩充内容"""
        current_length = len(content)
        expansion_ratio = target_length / current_length

        # 简单的扩充策略：添加详细说明
        if expansion_ratio > 1.2:
            content += "\n\n## 补充说明\n\n"
            content += "基于以上内容，我们进一步阐述如下要点：\n"
            content += "1. 技术实现的详细步骤和方法\n"
            content += "2. 质量保证措施和风险控制方案\n"
            content += "3. 项目管理和沟通机制\n"

        return content

    def _compress_content(self, content: str, target_length: int) -> str:
        """压缩内容"""
        # 简单的压缩策略：截断到目标长度
        if len(content) > target_length:
            content = content[:target_length]
            # 确保在句子边界截断
            last_period = content.rfind('。')
            if last_period > target_length * 0.9:
                content = content[:last_period + 1]

        return content

    def _evaluate_quality(self, content: str) -> float:
        """评估内容质量"""
        score = 0.0

        # 检查长度
        if 1000 < len(content) < 10000:
            score += 0.2

        # 检查结构（是否有标题）
        if '#' in content:
            score += 0.2

        # 检查完整性（是否有多个段落）
        if content.count('\n\n') > 3:
            score += 0.2

        # 检查专业性（是否包含专业术语）
        professional_terms = ['技术', '方案', '实施', '管理', '质量', '标准']
        term_count = sum(1 for term in professional_terms if term in content)
        score += min(0.2, term_count * 0.05)

        # 检查可读性（句子不要太长）
        sentences = content.split('。')
        avg_sentence_length = sum(len(s) for s in sentences) / max(len(sentences), 1)
        if 20 < avg_sentence_length < 50:
            score += 0.2

        return min(1.0, score)

    def _assemble_document(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """组装最终文档"""
        document = {
            'title': '投标文档',
            'sections': [],
            'total_words': 0,
            'metadata': {
                'generation_time': self._get_timestamp(),
                'models_used': [],
                'quality_scores': []
            }
        }

        for result in results:
            document['sections'].append({
                'name': result['section']['name'],
                'content': result['content'],
                'word_count': result['metadata']['word_count'],
                'model': result['metadata']['model'],
                'quality_score': result['metadata']['quality_score']
            })

            document['total_words'] += result['metadata']['word_count']
            document['metadata']['models_used'].append(result['metadata']['model'])
            document['metadata']['quality_scores'].append(result['metadata']['quality_score'])

        # 计算平均质量分数
        if document['metadata']['quality_scores']:
            avg_quality = sum(document['metadata']['quality_scores']) / len(document['metadata']['quality_scores'])
            document['metadata']['average_quality'] = avg_quality

        return document

    def _get_timestamp(self) -> str:
        """获取时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()
```

## 3. 配置文件

```python
# content_generation/config.py

import os
from typing import Dict, Any

class Config:
    """配置类"""

    # API配置
    GPT4_ENDPOINT = os.getenv('GPT4_ENDPOINT', 'https://api.openai.com/v1/chat/completions')
    GPT4_API_KEY = os.getenv('GPT4_API_KEY', '')

    GPT35_ENDPOINT = os.getenv('GPT35_ENDPOINT', 'https://api.openai.com/v1/chat/completions')
    GPT35_API_KEY = os.getenv('GPT35_API_KEY', '')

    CLAUDE_ENDPOINT = os.getenv('CLAUDE_ENDPOINT', 'https://api.anthropic.com/v1/messages')
    CLAUDE_API_KEY = os.getenv('CLAUDE_API_KEY', '')

    # Redis配置
    REDIS_HOST = os.getenv('REDIS_HOST', 'localhost')
    REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
    REDIS_DB = int(os.getenv('REDIS_DB', 0))

    # 生成配置
    MAX_CONCURRENT_GENERATIONS = 5
    DEFAULT_WORD_LIMIT = 50000
    CACHE_EXPIRY_SECONDS = 3600

    # 质量控制配置
    MIN_QUALITY_SCORE = 0.7
    MAX_RETRY_COUNT = 3

    @classmethod
    def to_dict(cls) -> Dict[str, Any]:
        """转换为字典"""
        return {
            key: value for key, value in cls.__dict__.items()
            if not key.startswith('_') and not callable(value)
        }
```

## 4. 主程序入口

```python
# content_generation/main.py

import asyncio
import logging
from typing import Dict, Any
from core.content_planner import ContentPlanningEngine
from core.knowledge_fusion import KnowledgeFusionEngine
from core.generator import MultiModelGenerator
from config import Config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ContentGenerationService:
    """内容生成服务主类"""

    def __init__(self):
        self.config = Config.to_dict()
        self.planner = ContentPlanningEngine()
        self.fusion_engine = KnowledgeFusionEngine()
        self.generator = MultiModelGenerator(self.config)

    async def generate_bid_document(self,
                                   project_data: Dict[str, Any]) -> Dict[str, Any]:
        """生成标书文档"""
        try:
            logger.info(f"Starting bid document generation for project: {project_data.get('project_id')}")

            # 1. 内容规划
            plan = self.planner.create_content_plan(
                project_data['requirements'],
                project_data.get('word_limit', 50000)
            )

            # 2. 能力匹配和知识融合
            matched_capabilities = self.fusion_engine.match_capabilities(
                project_data['requirements'].get('key_requirements', []),
                project_data.get('company_capabilities', {})
            )

            # 3. 多模型协同生成
            document = await self.generator.generate_content(
                plan.__dict__,
                matched_capabilities
            )

            # 4. 质量检查
            quality_score = self._check_quality(document)
            document['quality_score'] = quality_score

            logger.info(f"Document generation completed with quality score: {quality_score}")

            return {
                'success': True,
                'document': document,
                'metadata': {
                    'project_id': project_data.get('project_id'),
                    'generation_time': self._get_timestamp(),
                    'quality_score': quality_score
                }
            }

        except Exception as e:
            logger.error(f"Error generating document: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _check_quality(self, document: Dict[str, Any]) -> float:
        """检查文档质量"""
        scores = document.get('metadata', {}).get('quality_scores', [])
        if scores:
            return sum(scores) / len(scores)
        return 0.0

    def _get_timestamp(self) -> str:
        """获取时间戳"""
        from datetime import datetime
        return datetime.now().isoformat()


# 使用示例
async def main():
    """主函数"""
    service = ContentGenerationService()

    # 示例数据
    project_data = {
        'project_id': 'PROJ-2025-001',
        'requirements': {
            'content': '某政府部门信息化系统建设项目招标...',
            'key_requirements': [
                '系统需支持1000用户并发',
                '具备数据加密功能',
                '提供7*24小时技术支持'
            ]
        },
        'company_capabilities': {
            'products': [
                {
                    'name': '企业信息化平台',
                    'description': '综合信息管理系统',
                    'features': ['高并发', '数据加密', '模块化设计']
                }
            ],
            'cases': [
                {
                    'name': '某市政府OA系统',
                    'client': '某市政府',
                    'amount': 500
                }
            ]
        },
        'word_limit': 30000
    }

    result = await service.generate_bid_document(project_data)

    if result['success']:
        print(f"文档生成成功！质量分数：{result['document']['quality_score']}")
        print(f"总字数：{result['document']['total_words']}")
        print(f"章节数：{len(result['document']['sections'])}")
    else:
        print(f"生成失败：{result['error']}")


if __name__ == "__main__":
    asyncio.run(main())
```

## 5. 测试代码

```python
# tests/test_content_generation.py

import unittest
import asyncio
from unittest.mock import Mock, patch
from content_generation.core.content_planner import ContentPlanningEngine
from content_generation.core.knowledge_fusion import KnowledgeFusionEngine

class TestContentPlanning(unittest.TestCase):
    """内容规划测试"""

    def setUp(self):
        self.planner = ContentPlanningEngine()

    def test_analyze_requirements(self):
        """测试需求分析"""
        requirements = {
            'project_id': 'TEST-001',
            'content': '软件开发项目，需要开发一个电商平台系统'
        }

        analysis = self.planner.analyze_requirements(requirements)

        self.assertEqual(analysis['project_type'], 'software')
        self.assertIn('industry', analysis)

    def test_create_content_plan(self):
        """测试内容规划创建"""
        requirements = {
            'project_id': 'TEST-001',
            'content': '项目需要技术方案和实施计划'
        }

        plan = self.planner.create_content_plan(requirements, 10000)

        self.assertEqual(plan.project_id, 'TEST-001')
        self.assertEqual(plan.word_count, 10000)
        self.assertGreater(len(plan.sections), 0)


class TestKnowledgeFusion(unittest.TestCase):
    """知识融合测试"""

    def setUp(self):
        self.fusion = KnowledgeFusionEngine()

    def test_match_products(self):
        """测试产品匹配"""
        requirements = ['需要OA系统', '支持移动办公']
        products = [
            {
                'name': 'OA办公系统',
                'description': '企业办公自动化系统',
                'features': ['移动办公', '流程审批']
            }
        ]

        matches = self.fusion._match_products(requirements, products)

        self.assertGreater(len(matches), 0)
        self.assertIn('match_score', matches[0])

if __name__ == '__main__':
    unittest.main()
```

---

## 修改历史

| 日期 | 版本 | 修改者 | 修改内容概要 |
|------|------|--------|-------------|
| 2025-11-30 12:45 | 1.0 | claude-opus-4-1-20250805 | 从业务设计文档中提取并保存实现代码 |