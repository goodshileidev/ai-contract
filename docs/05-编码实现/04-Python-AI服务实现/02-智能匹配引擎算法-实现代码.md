---
文档类型: 实现文档
需求编号: REQ-2025-11-002
创建日期: 2025-11-30 13:00
创建者: claude-opus-4-1-20250805
最后更新: 2025-11-30 13:00
更新者: claude-opus-4-1-20250805
状态: 草稿
---

# 智能匹配引擎算法 - Python实现代码

本文档包含智能匹配引擎的完整Python实现代码，用于将招标需求与企业能力进行智能匹配。

## 1. 导入依赖

```python
import numpy as np
from typing import Dict, List, Any, Tuple, Optional
from dataclasses import dataclass, field
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import networkx as nx
from sentence_transformers import SentenceTransformer
import torch
import asyncio
import logging
from datetime import datetime
import json
import pandas as pd
from collections import defaultdict
```

## 2. 数据模型定义

```python
@dataclass
class CapabilityMatch:
    """能力匹配结果"""
    capability_id: str
    capability_name: str
    match_score: float
    match_details: Dict[str, Any]
    gaps: List[str]
    strengths: List[str]

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'capability_id': self.capability_id,
            'capability_name': self.capability_name,
            'match_score': self.match_score,
            'match_details': self.match_details,
            'gaps': self.gaps,
            'strengths': self.strengths
        }

@dataclass
class RequirementMatch:
    """需求匹配结果"""
    requirement_id: str
    requirement_text: str
    matched_capabilities: List[CapabilityMatch]
    overall_match_score: float
    coverage_percentage: float
    risk_assessment: Dict[str, Any]

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            'requirement_id': self.requirement_id,
            'requirement_text': self.requirement_text,
            'matched_capabilities': [cap.to_dict() for cap in self.matched_capabilities],
            'overall_match_score': self.overall_match_score,
            'coverage_percentage': self.coverage_percentage,
            'risk_assessment': self.risk_assessment
        }

@dataclass
class GapAnalysis:
    """差距分析结果"""
    capability_gaps: List[Dict[str, Any]]
    experience_gaps: List[Dict[str, Any]]
    resource_gaps: List[Dict[str, Any]]
    certification_gaps: List[Dict[str, Any]]
    overall_gap_score: float
    mitigation_strategies: List[Dict[str, Any]]
```

## 3. 智能匹配引擎核心实现

```python
class IntelligentMatchingEngine:
    """智能匹配引擎"""

    def __init__(self):
        self.tfidf_vectorizer = TfidfVectorizer(
            max_features=5000,
            ngram_range=(1, 3),
            stop_words=None
        )

        # 语义相似度模型
        self.semantic_model = SentenceTransformer('paraphrase-multilingual-mpnet-base-v2')

        # 匹配权重配置
        self.match_weights = {
            'semantic_similarity': 0.35,
            'keyword_matching': 0.25,
            'experience_matching': 0.25,
            'certification_matching': 0.15
        }

        # 能力类型权重
        self.capability_type_weights = {
            'product': 0.3,
            'service': 0.3,
            'project': 0.2,
            'personnel': 0.1,
            'technology': 0.1
        }

        self.logger = logging.getLogger(__name__)

    async def match_requirements_to_capabilities(self,
                                                requirements: List[str],
                                                company_capabilities: List[Dict[str, Any]],
                                                matching_criteria: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        将需求匹配到企业能力

        Args:
            requirements: 需求列表
            company_capabilities: 企业能力列表
            matching_criteria: 匹配条件

        Returns:
            匹配结果
        """
        try:
            # 1. 预处理能力数据
            processed_capabilities = await self._preprocess_capabilities(company_capabilities)

            # 2. 计算需求-能力匹配矩阵
            match_matrix = await self._calculate_match_matrix(requirements, processed_capabilities)

            # 3. 分析匹配结果
            match_analysis = await self._analyze_match_results(match_matrix, requirements, processed_capabilities)

            # 4. 识别差距和优势
            gap_analysis = await self._analyze_gaps(match_analysis, requirements)

            # 5. 生成匹配建议
            recommendations = await self._generate_recommendations(match_analysis, gap_analysis)

            # 6. 计算整体匹配分数
            overall_metrics = self._calculate_overall_metrics(match_analysis)

            return {
                'match_analysis': match_analysis,
                'gap_analysis': gap_analysis,
                'recommendations': recommendations,
                'overall_metrics': overall_metrics,
                'matching_metadata': {
                    'total_requirements': len(requirements),
                    'total_capabilities': len(company_capabilities),
                    'matching_criteria': matching_criteria,
                    'timestamp': datetime.now().isoformat()
                }
            }
        except Exception as e:
            self.logger.error(f"匹配过程发生错误: {str(e)}")
            raise MatchingError(f"匹配失败: {str(e)}")

    async def _preprocess_capabilities(self, capabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """预处理企业能力数据"""
        processed = []
        for cap in capabilities:
            processed_cap = cap.copy()

            # 提取关键词
            if 'description' in cap:
                processed_cap['keywords'] = self._extract_keywords(cap['description'])

            # 标准化能力类型
            if 'type' in cap:
                processed_cap['normalized_type'] = self._normalize_capability_type(cap['type'])

            # 解析技术标签
            if 'tech_tags' in cap:
                processed_cap['tech_keywords'] = self._parse_tech_tags(cap['tech_tags'])

            processed.append(processed_cap)

        return processed

    def _extract_keywords(self, text: str) -> List[str]:
        """提取关键词"""
        # 使用jieba或其他分词工具
        keywords = []
        # 这里简化处理，实际应使用更复杂的关键词提取算法
        words = text.lower().split()
        keywords = [w for w in words if len(w) > 2]
        return keywords

    def _normalize_capability_type(self, cap_type: str) -> str:
        """标准化能力类型"""
        type_mapping = {
            '产品': 'product',
            '服务': 'service',
            '项目': 'project',
            '人员': 'personnel',
            '技术': 'technology'
        }
        return type_mapping.get(cap_type, 'other')

    def _parse_tech_tags(self, tags: List[str]) -> List[str]:
        """解析技术标签"""
        parsed_tags = []
        for tag in tags:
            # 标准化和扩展技术标签
            normalized = tag.lower().strip()
            parsed_tags.append(normalized)

            # 添加同义词
            if normalized == 'ml':
                parsed_tags.append('machine learning')
            elif normalized == 'ai':
                parsed_tags.append('artificial intelligence')

        return list(set(parsed_tags))

    async def _calculate_match_matrix(self,
                                     requirements: List[str],
                                     capabilities: List[Dict[str, Any]]) -> np.ndarray:
        """计算需求-能力匹配矩阵"""
        n_reqs = len(requirements)
        n_caps = len(capabilities)
        match_matrix = np.zeros((n_reqs, n_caps))

        # 1. 计算语义相似度
        req_embeddings = self.semantic_model.encode(requirements)
        cap_texts = [cap.get('description', '') for cap in capabilities]
        cap_embeddings = self.semantic_model.encode(cap_texts)
        semantic_scores = cosine_similarity(req_embeddings, cap_embeddings)

        # 2. 计算关键词匹配度
        keyword_scores = self._calculate_keyword_matches(requirements, capabilities)

        # 3. 计算经验匹配度
        experience_scores = self._calculate_experience_matches(requirements, capabilities)

        # 4. 计算资质匹配度
        certification_scores = self._calculate_certification_matches(requirements, capabilities)

        # 5. 加权融合
        match_matrix = (
            self.match_weights['semantic_similarity'] * semantic_scores +
            self.match_weights['keyword_matching'] * keyword_scores +
            self.match_weights['experience_matching'] * experience_scores +
            self.match_weights['certification_matching'] * certification_scores
        )

        return match_matrix

    def _calculate_keyword_matches(self, requirements: List[str], capabilities: List[Dict[str, Any]]) -> np.ndarray:
        """计算关键词匹配分数"""
        n_reqs = len(requirements)
        n_caps = len(capabilities)
        scores = np.zeros((n_reqs, n_caps))

        for i, req in enumerate(requirements):
            req_keywords = set(self._extract_keywords(req))
            for j, cap in enumerate(capabilities):
                cap_keywords = set(cap.get('keywords', []))
                if req_keywords and cap_keywords:
                    # Jaccard相似度
                    intersection = len(req_keywords & cap_keywords)
                    union = len(req_keywords | cap_keywords)
                    scores[i, j] = intersection / union if union > 0 else 0

        return scores

    def _calculate_experience_matches(self, requirements: List[str], capabilities: List[Dict[str, Any]]) -> np.ndarray:
        """计算经验匹配分数"""
        n_reqs = len(requirements)
        n_caps = len(capabilities)
        scores = np.zeros((n_reqs, n_caps))

        for i, req in enumerate(requirements):
            for j, cap in enumerate(capabilities):
                # 检查项目经验
                if 'projects' in cap:
                    project_score = self._evaluate_project_experience(req, cap['projects'])
                    scores[i, j] = project_score

        return scores

    def _calculate_certification_matches(self, requirements: List[str], capabilities: List[Dict[str, Any]]) -> np.ndarray:
        """计算资质匹配分数"""
        n_reqs = len(requirements)
        n_caps = len(capabilities)
        scores = np.zeros((n_reqs, n_caps))

        for i, req in enumerate(requirements):
            for j, cap in enumerate(capabilities):
                # 检查资质证书
                if 'certifications' in cap:
                    cert_score = self._evaluate_certifications(req, cap['certifications'])
                    scores[i, j] = cert_score

        return scores

    def _evaluate_project_experience(self, requirement: str, projects: List[Dict[str, Any]]) -> float:
        """评估项目经验匹配度"""
        if not projects:
            return 0.0

        scores = []
        for project in projects:
            # 项目规模评分
            scale_score = self._evaluate_project_scale(requirement, project)

            # 项目类型评分
            type_score = self._evaluate_project_type(requirement, project)

            # 时间相关性评分
            recency_score = self._evaluate_project_recency(project)

            # 综合评分
            project_score = 0.4 * scale_score + 0.4 * type_score + 0.2 * recency_score
            scores.append(project_score)

        # 返回最高分
        return max(scores) if scores else 0.0

    def _evaluate_project_scale(self, requirement: str, project: Dict[str, Any]) -> float:
        """评估项目规模匹配度"""
        # 简化的规模评估逻辑
        if 'amount' in project:
            amount = project['amount']
            if amount > 10000000:  # 大型项目
                return 1.0
            elif amount > 1000000:  # 中型项目
                return 0.7
            else:  # 小型项目
                return 0.4
        return 0.5

    def _evaluate_project_type(self, requirement: str, project: Dict[str, Any]) -> float:
        """评估项目类型匹配度"""
        # 使用语义相似度评估
        if 'description' in project:
            req_embedding = self.semantic_model.encode([requirement])
            proj_embedding = self.semantic_model.encode([project['description']])
            similarity = cosine_similarity(req_embedding, proj_embedding)[0, 0]
            return float(similarity)
        return 0.0

    def _evaluate_project_recency(self, project: Dict[str, Any]) -> float:
        """评估项目时间相关性"""
        if 'completion_date' in project:
            # 计算项目完成时间距今的月数
            completion_date = datetime.fromisoformat(project['completion_date'])
            months_ago = (datetime.now() - completion_date).days / 30

            if months_ago < 6:
                return 1.0
            elif months_ago < 12:
                return 0.8
            elif months_ago < 24:
                return 0.6
            elif months_ago < 36:
                return 0.4
            else:
                return 0.2
        return 0.5

    def _evaluate_certifications(self, requirement: str, certifications: List[Dict[str, Any]]) -> float:
        """评估资质证书匹配度"""
        if not certifications:
            return 0.0

        # 提取需求中的资质关键词
        cert_keywords = self._extract_certification_keywords(requirement)

        if not cert_keywords:
            return 0.5  # 没有明确资质要求

        matched_certs = 0
        for cert in certifications:
            cert_name = cert.get('name', '').lower()
            for keyword in cert_keywords:
                if keyword in cert_name:
                    matched_certs += 1
                    break

        # 计算匹配率
        return matched_certs / len(cert_keywords) if cert_keywords else 0.0

    def _extract_certification_keywords(self, text: str) -> List[str]:
        """提取资质相关关键词"""
        cert_patterns = [
            'ISO', 'CMMI', '高新技术', '软件企业',
            '系统集成', '信息安全', '质量管理',
            '环境管理', '职业健康'
        ]

        found_keywords = []
        text_lower = text.lower()
        for pattern in cert_patterns:
            if pattern.lower() in text_lower:
                found_keywords.append(pattern.lower())

        return found_keywords

    async def _analyze_match_results(self,
                                    match_matrix: np.ndarray,
                                    requirements: List[str],
                                    capabilities: List[Dict[str, Any]]) -> List[RequirementMatch]:
        """分析匹配结果"""
        match_results = []

        for i, requirement in enumerate(requirements):
            # 获取该需求的所有匹配分数
            scores = match_matrix[i]

            # 找出匹配度最高的能力
            top_indices = np.argsort(scores)[::-1][:5]  # Top 5

            matched_caps = []
            for idx in top_indices:
                if scores[idx] > 0.3:  # 阈值过滤
                    cap = capabilities[idx]

                    # 识别差距和优势
                    gaps = self._identify_capability_gaps(requirement, cap)
                    strengths = self._identify_capability_strengths(requirement, cap)

                    matched_cap = CapabilityMatch(
                        capability_id=cap.get('id', f'cap_{idx}'),
                        capability_name=cap.get('name', ''),
                        match_score=float(scores[idx]),
                        match_details={
                            'type': cap.get('normalized_type', 'unknown'),
                            'keywords_matched': len(set(self._extract_keywords(requirement)) &
                                                 set(cap.get('keywords', [])))
                        },
                        gaps=gaps,
                        strengths=strengths
                    )
                    matched_caps.append(matched_cap)

            # 计算需求的整体匹配情况
            overall_score = np.max(scores) if len(scores) > 0 else 0.0
            coverage = len([s for s in scores if s > 0.3]) / len(scores) if len(scores) > 0 else 0.0

            # 风险评估
            risk_assessment = self._assess_requirement_risk(requirement, matched_caps)

            req_match = RequirementMatch(
                requirement_id=f'req_{i}',
                requirement_text=requirement,
                matched_capabilities=matched_caps,
                overall_match_score=float(overall_score),
                coverage_percentage=float(coverage * 100),
                risk_assessment=risk_assessment
            )
            match_results.append(req_match)

        return match_results

    def _identify_capability_gaps(self, requirement: str, capability: Dict[str, Any]) -> List[str]:
        """识别能力差距"""
        gaps = []

        # 检查技术差距
        req_keywords = set(self._extract_keywords(requirement))
        cap_keywords = set(capability.get('keywords', []))
        missing_keywords = req_keywords - cap_keywords

        if missing_keywords:
            gaps.append(f"缺少关键技术/能力: {', '.join(list(missing_keywords)[:3])}")

        # 检查资质差距
        cert_keywords = self._extract_certification_keywords(requirement)
        if cert_keywords and 'certifications' in capability:
            existing_certs = [c.get('name', '').lower() for c in capability['certifications']]
            missing_certs = [c for c in cert_keywords if not any(c in ec for ec in existing_certs)]
            if missing_certs:
                gaps.append(f"缺少资质: {', '.join(missing_certs)}")

        # 检查经验差距
        if '大型项目' in requirement and capability.get('projects'):
            large_projects = [p for p in capability['projects'] if p.get('amount', 0) > 10000000]
            if not large_projects:
                gaps.append("缺少大型项目经验")

        return gaps

    def _identify_capability_strengths(self, requirement: str, capability: Dict[str, Any]) -> List[str]:
        """识别能力优势"""
        strengths = []

        # 检查技术优势
        cap_keywords = set(capability.get('keywords', []))
        req_keywords = set(self._extract_keywords(requirement))
        matched_keywords = req_keywords & cap_keywords

        if len(matched_keywords) > 3:
            strengths.append(f"技术匹配度高: {', '.join(list(matched_keywords)[:3])}")

        # 检查项目经验优势
        if 'projects' in capability:
            recent_projects = [p for p in capability['projects']
                             if self._evaluate_project_recency(p) > 0.8]
            if len(recent_projects) > 3:
                strengths.append(f"丰富的近期项目经验 ({len(recent_projects)}个)")

        # 检查资质优势
        if 'certifications' in capability:
            high_level_certs = [c for c in capability['certifications']
                              if any(keyword in c.get('name', '').lower()
                                   for keyword in ['cmmi5', 'iso27001', '高新技术'])]
            if high_level_certs:
                strengths.append(f"高级别资质认证")

        return strengths

    def _assess_requirement_risk(self, requirement: str, matched_capabilities: List[CapabilityMatch]) -> Dict[str, Any]:
        """评估需求风险"""
        risk_level = 'low'
        risk_factors = []
        mitigation_suggestions = []

        if not matched_capabilities:
            risk_level = 'high'
            risk_factors.append("没有匹配的能力")
            mitigation_suggestions.append("考虑外包或寻找合作伙伴")
        else:
            # 检查最高匹配分数
            max_score = max([cap.match_score for cap in matched_capabilities])

            if max_score < 0.5:
                risk_level = 'high'
                risk_factors.append("匹配度低")
                mitigation_suggestions.append("需要能力提升或外部支持")
            elif max_score < 0.7:
                risk_level = 'medium'
                risk_factors.append("匹配度中等")
                mitigation_suggestions.append("建议加强相关能力")

            # 检查差距
            all_gaps = []
            for cap in matched_capabilities:
                all_gaps.extend(cap.gaps)

            if len(all_gaps) > 5:
                risk_level = 'high' if risk_level != 'high' else risk_level
                risk_factors.append(f"存在多项能力差距 ({len(all_gaps)}项)")
                mitigation_suggestions.append("制定能力补充计划")

        return {
            'risk_level': risk_level,
            'risk_factors': risk_factors,
            'mitigation_suggestions': mitigation_suggestions,
            'confidence_score': self._calculate_risk_confidence(matched_capabilities)
        }

    def _calculate_risk_confidence(self, matched_capabilities: List[CapabilityMatch]) -> float:
        """计算风险评估置信度"""
        if not matched_capabilities:
            return 1.0  # 确定是高风险

        scores = [cap.match_score for cap in matched_capabilities]
        avg_score = np.mean(scores)
        std_score = np.std(scores)

        # 分数越集中，置信度越高
        confidence = 1.0 - (std_score / (avg_score + 0.01))
        return max(0.0, min(1.0, confidence))

    async def _analyze_gaps(self, match_analysis: List[RequirementMatch], requirements: List[str]) -> Dict[str, Any]:
        """分析能力差距"""
        capability_gaps = []
        experience_gaps = []
        resource_gaps = []
        certification_gaps = []

        for req_match in match_analysis:
            # 收集所有差距
            for cap in req_match.matched_capabilities:
                for gap in cap.gaps:
                    if '技术' in gap or '能力' in gap:
                        capability_gaps.append({
                            'requirement': req_match.requirement_text,
                            'gap': gap,
                            'severity': self._assess_gap_severity(gap)
                        })
                    elif '经验' in gap or '项目' in gap:
                        experience_gaps.append({
                            'requirement': req_match.requirement_text,
                            'gap': gap,
                            'severity': self._assess_gap_severity(gap)
                        })
                    elif '资源' in gap or '人员' in gap:
                        resource_gaps.append({
                            'requirement': req_match.requirement_text,
                            'gap': gap,
                            'severity': self._assess_gap_severity(gap)
                        })
                    elif '资质' in gap or '认证' in gap:
                        certification_gaps.append({
                            'requirement': req_match.requirement_text,
                            'gap': gap,
                            'severity': self._assess_gap_severity(gap)
                        })

        # 计算整体差距分数
        total_gaps = len(capability_gaps) + len(experience_gaps) + len(resource_gaps) + len(certification_gaps)
        overall_gap_score = min(1.0, total_gaps / (len(requirements) * 2))  # 假设平均每个需求2个差距为满分

        # 生成缓解策略
        mitigation_strategies = self._generate_mitigation_strategies(
            capability_gaps, experience_gaps, resource_gaps, certification_gaps
        )

        return {
            'capability_gaps': capability_gaps,
            'experience_gaps': experience_gaps,
            'resource_gaps': resource_gaps,
            'certification_gaps': certification_gaps,
            'overall_gap_score': overall_gap_score,
            'mitigation_strategies': mitigation_strategies,
            'summary': {
                'total_gaps': total_gaps,
                'critical_gaps': len([g for g in capability_gaps + experience_gaps + resource_gaps + certification_gaps
                                    if g['severity'] == 'high']),
                'feasibility_score': 1.0 - overall_gap_score
            }
        }

    def _assess_gap_severity(self, gap: str) -> str:
        """评估差距严重程度"""
        high_severity_keywords = ['必须', '必需', '强制', '核心', '关键']
        medium_severity_keywords = ['建议', '推荐', '优先', '重要']

        gap_lower = gap.lower()

        if any(keyword in gap_lower for keyword in high_severity_keywords):
            return 'high'
        elif any(keyword in gap_lower for keyword in medium_severity_keywords):
            return 'medium'
        else:
            return 'low'

    def _generate_mitigation_strategies(self,
                                       capability_gaps: List[Dict],
                                       experience_gaps: List[Dict],
                                       resource_gaps: List[Dict],
                                       certification_gaps: List[Dict]) -> List[Dict[str, Any]]:
        """生成缓解策略"""
        strategies = []

        # 能力差距缓解策略
        if capability_gaps:
            strategies.append({
                'type': 'capability',
                'strategy': '技术能力提升',
                'actions': [
                    '引入相关技术专家或顾问',
                    '开展技术培训和知识转移',
                    '采购或开发相关技术工具'
                ],
                'priority': 'high' if any(g['severity'] == 'high' for g in capability_gaps) else 'medium',
                'timeline': '1-2个月'
            })

        # 经验差距缓解策略
        if experience_gaps:
            strategies.append({
                'type': 'experience',
                'strategy': '项目经验补充',
                'actions': [
                    '寻找有相关经验的合作伙伴',
                    '招聘有经验的项目经理',
                    '参考类似项目案例和最佳实践'
                ],
                'priority': 'medium',
                'timeline': '2-3个月'
            })

        # 资源差距缓解策略
        if resource_gaps:
            strategies.append({
                'type': 'resource',
                'strategy': '资源补充',
                'actions': [
                    '临时招聘或外包关键岗位',
                    '调配其他项目资源',
                    '与人力资源公司合作'
                ],
                'priority': 'high',
                'timeline': '2-4周'
            })

        # 资质差距缓解策略
        if certification_gaps:
            high_priority_certs = [g for g in certification_gaps if g['severity'] == 'high']
            if high_priority_certs:
                strategies.append({
                    'type': 'certification',
                    'strategy': '资质获取',
                    'actions': [
                        '紧急申请必需的资质认证',
                        '寻找有资质的分包商',
                        '考虑联合投标'
                    ],
                    'priority': 'critical',
                    'timeline': '立即行动'
                })

        return strategies

    async def _generate_recommendations(self, match_analysis: List[RequirementMatch], gap_analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """生成投标建议"""
        recommendations = []

        # 计算整体匹配情况
        avg_match_score = np.mean([req.overall_match_score for req in match_analysis])
        high_match_reqs = [req for req in match_analysis if req.overall_match_score > 0.7]
        low_match_reqs = [req for req in match_analysis if req.overall_match_score < 0.5]

        # 基于匹配度的建议
        if avg_match_score > 0.7:
            recommendations.append({
                'category': 'strategy',
                'recommendation': '独立投标',
                'reasoning': f'整体匹配度高 ({avg_match_score:.2%})，建议独立投标',
                'confidence': 0.9,
                'actions': [
                    '突出核心优势',
                    '准备详细的案例展示',
                    '强调技术实力和项目经验'
                ]
            })
        elif avg_match_score > 0.5:
            recommendations.append({
                'category': 'strategy',
                'recommendation': '补充能力后投标',
                'reasoning': f'整体匹配度中等 ({avg_match_score:.2%})，需要补充部分能力',
                'confidence': 0.7,
                'actions': gap_analysis['mitigation_strategies']
            })
        else:
            recommendations.append({
                'category': 'strategy',
                'recommendation': '联合投标或放弃',
                'reasoning': f'整体匹配度低 ({avg_match_score:.2%})，建议寻找合作伙伴或放弃',
                'confidence': 0.8,
                'actions': [
                    '寻找互补的合作伙伴',
                    '评估投标成本效益',
                    '考虑作为分包商参与'
                ]
            })

        # 基于风险的建议
        high_risk_reqs = [req for req in match_analysis
                         if req.risk_assessment['risk_level'] == 'high']
        if high_risk_reqs:
            recommendations.append({
                'category': 'risk',
                'recommendation': '重点关注高风险需求',
                'reasoning': f'存在 {len(high_risk_reqs)} 项高风险需求',
                'confidence': 0.85,
                'actions': [
                    '为高风险需求制定备选方案',
                    '在标书中明确风险管理措施',
                    '预留风险应对资源'
                ]
            })

        # 基于优势的建议
        strengths_list = []
        for req in match_analysis:
            for cap in req.matched_capabilities:
                strengths_list.extend(cap.strengths)

        if strengths_list:
            unique_strengths = list(set(strengths_list))[:5]
            recommendations.append({
                'category': 'strengths',
                'recommendation': '突出竞争优势',
                'reasoning': f'识别到 {len(unique_strengths)} 项核心优势',
                'confidence': 0.9,
                'actions': unique_strengths
            })

        # 评分和排序
        for rec in recommendations:
            rec['score'] = self._calculate_recommendation_score(
                rec['confidence'],
                avg_match_score,
                gap_analysis['overall_gap_score']
            )

        # 按分数排序
        recommendations.sort(key=lambda x: x['score'], reverse=True)

        return recommendations

    def _calculate_recommendation_score(self, confidence: float, match_score: float, gap_score: float) -> float:
        """计算推荐分数"""
        return confidence * 0.4 + match_score * 0.4 + (1 - gap_score) * 0.2

    def _calculate_overall_metrics(self, match_analysis: List[RequirementMatch]) -> Dict[str, Any]:
        """计算整体指标"""
        if not match_analysis:
            return {
                'overall_match_score': 0.0,
                'coverage_rate': 0.0,
                'risk_distribution': {},
                'confidence_level': 0.0
            }

        # 匹配分数统计
        match_scores = [req.overall_match_score for req in match_analysis]

        # 覆盖率统计
        covered_reqs = [req for req in match_analysis if req.overall_match_score > 0.5]
        coverage_rate = len(covered_reqs) / len(match_analysis)

        # 风险分布
        risk_distribution = defaultdict(int)
        for req in match_analysis:
            risk_level = req.risk_assessment['risk_level']
            risk_distribution[risk_level] += 1

        # 置信度
        confidence_scores = [req.risk_assessment['confidence_score'] for req in match_analysis]

        return {
            'overall_match_score': float(np.mean(match_scores)),
            'match_score_std': float(np.std(match_scores)),
            'max_match_score': float(np.max(match_scores)),
            'min_match_score': float(np.min(match_scores)),
            'coverage_rate': float(coverage_rate),
            'covered_requirements': len(covered_reqs),
            'total_requirements': len(match_analysis),
            'risk_distribution': dict(risk_distribution),
            'confidence_level': float(np.mean(confidence_scores)),
            'recommendation_score': self._calculate_overall_recommendation_score(
                np.mean(match_scores), coverage_rate, risk_distribution
            )
        }

    def _calculate_overall_recommendation_score(self,
                                               avg_match: float,
                                               coverage: float,
                                               risk_dist: Dict[str, int]) -> float:
        """计算整体推荐分数"""
        # 基础分数
        base_score = avg_match * 0.5 + coverage * 0.3

        # 风险调整
        total_risks = sum(risk_dist.values())
        if total_risks > 0:
            high_risk_ratio = risk_dist.get('high', 0) / total_risks
            medium_risk_ratio = risk_dist.get('medium', 0) / total_risks
            risk_penalty = high_risk_ratio * 0.3 + medium_risk_ratio * 0.1
            base_score *= (1 - risk_penalty)

        return min(1.0, max(0.0, base_score))
```

## 4. 异常处理

```python
class MatchingError(Exception):
    """匹配引擎异常"""
    pass

class CapabilityError(Exception):
    """能力处理异常"""
    pass

class RequirementError(Exception):
    """需求处理异常"""
    pass
```

## 5. 使用示例

```python
async def main():
    """主程序入口"""
    # 初始化匹配引擎
    engine = IntelligentMatchingEngine()

    # 示例数据
    requirements = [
        "需要具备云计算平台开发经验，熟悉AWS或阿里云",
        "要求有ISO27001信息安全管理体系认证",
        "需要5年以上大型项目管理经验",
        "要求精通Python和机器学习算法"
    ]

    company_capabilities = [
        {
            'id': 'cap_001',
            'name': '云平台开发能力',
            'description': '具备AWS、阿里云、腾讯云等主流云平台开发和部署经验',
            'type': '技术',
            'keywords': ['云计算', 'AWS', '阿里云', '部署', 'DevOps'],
            'projects': [
                {
                    'name': '某金融云平台',
                    'amount': 15000000,
                    'completion_date': '2024-06-01',
                    'description': '基于AWS构建的金融级云平台'
                }
            ],
            'certifications': [
                {'name': 'AWS解决方案架构师认证', 'date': '2023-01-01'}
            ]
        },
        {
            'id': 'cap_002',
            'name': '信息安全管理',
            'description': '完善的信息安全管理体系',
            'type': '管理',
            'keywords': ['信息安全', '数据保护', '隐私'],
            'certifications': [
                {'name': 'ISO27001信息安全管理体系认证', 'date': '2022-05-01'},
                {'name': 'ISO27701隐私信息管理体系认证', 'date': '2023-03-01'}
            ]
        },
        {
            'id': 'cap_003',
            'name': 'AI算法开发',
            'description': '机器学习和深度学习算法开发能力',
            'type': '技术',
            'keywords': ['Python', '机器学习', '深度学习', 'TensorFlow', 'PyTorch'],
            'tech_tags': ['ML', 'AI', 'NLP', 'CV']
        }
    ]

    # 执行匹配
    try:
        results = await engine.match_requirements_to_capabilities(
            requirements=requirements,
            company_capabilities=company_capabilities
        )

        # 输出结果
        print("=== 匹配分析结果 ===")
        print(f"整体匹配分数: {results['overall_metrics']['overall_match_score']:.2%}")
        print(f"需求覆盖率: {results['overall_metrics']['coverage_rate']:.2%}")
        print(f"风险分布: {results['overall_metrics']['risk_distribution']}")

        print("\n=== 推荐策略 ===")
        for rec in results['recommendations']:
            print(f"- {rec['recommendation']}: {rec['reasoning']}")

    except MatchingError as e:
        print(f"匹配失败: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

## 6. 配置文件

```python
# config.py
MATCHING_CONFIG = {
    'semantic_model': 'paraphrase-multilingual-mpnet-base-v2',
    'match_weights': {
        'semantic_similarity': 0.35,
        'keyword_matching': 0.25,
        'experience_matching': 0.25,
        'certification_matching': 0.15
    },
    'thresholds': {
        'min_match_score': 0.3,
        'high_match_score': 0.7,
        'risk_threshold': 0.5
    },
    'max_recommendations': 10,
    'top_capabilities': 5
}
```

---

## 修改历史

| 日期 | 版本 | 修改者 | 修改内容概要 |
|------|------|--------|-------------|
| 2025-11-30 13:00 | 1.0 | claude-opus-4-1-20250805 | 从业务设计文档恢复智能匹配引擎实现代码 |