# Python FastAPI AI æœåŠ¡ä»»åŠ¡è¯¦ç»†è®¡åˆ’ - AI-004

**æ–‡æ¡£ç±»å‹**: å®æ–½æ–‡æ¡£
**éœ€æ±‚ç¼–å·**: REQ-AI-004
**åˆ›å»ºæ—¥æœŸ**: 2025-11-26
**åˆ›å»ºè€…**: claude-sonnet-4-5 (claude-sonnet-4-5-20250929)
**æœ€åæ›´æ–°**: 2025-11-27
**æ›´æ–°è€…**: claude-sonnet-4-5 (claude-sonnet-4-5-20250929)
**çŠ¶æ€**: å¾…å¼€å§‹

---

## ä¿®æ”¹å†å²

| æ—¥æœŸ | ç‰ˆæœ¬ | ä¿®æ”¹è€… | ä¿®æ”¹å†…å®¹æ¦‚è¦ |
|------|------|--------|-------------|
| 2025-11-27 14:55 | 2.0 | claude-sonnet-4-5 | ä» task-plan-python-ai-è¯¦ç»†.md æ‹†åˆ†å‡º AI-004 æ¨¡å— |
| 2025-11-26 | 1.0 | claude-sonnet-4-5 | åˆ›å»ºPython AIæœåŠ¡è¯¦ç»†ä»»åŠ¡è®¡åˆ’ |

---

## ğŸ“‘ æ–‡æ¡£å¯¼èˆª

**è¿”å›ç´¢å¼•**: [task-plan-python-ai-è¯¦ç»†-INDEX.md](./task-plan-python-ai-è¯¦ç»†-INDEX.md)

**å…¶ä»–æ¨¡å—**: [AI-001](./task-plan-python-ai-è¯¦ç»†-AI-001.md) | [AI-002](./task-plan-python-ai-è¯¦ç»†-AI-002.md) | [AI-003](./task-plan-python-ai-è¯¦ç»†-AI-003.md)

---

## AI-004: æ™ºèƒ½åŒ¹é…åˆ†æ

**éœ€æ±‚ç¼–å·**: REQ-AI-004
**è´Ÿè´£äºº**: Python AI å¼€å‘
**ä¼˜å…ˆçº§**: P2 - ä¸­ä¼˜å…ˆçº§
**å¼€å§‹æ—¶é—´**: YYYY-MM-DD
**é¢„è®¡å®Œæˆ**: YYYY-MM-DD
**å®é™…å®Œæˆ**: -
**å½“å‰çŠ¶æ€**: â¸ï¸ å¾…å¼€å§‹
**å®Œæˆè¿›åº¦**: 0% (0/3 äºŒçº§ä»»åŠ¡)

### æ¨¡å—æ¦‚è¿°

æ™ºèƒ½åŒ¹é…åˆ†ææ˜¯AIæ ‡ä¹¦ç”Ÿæˆçš„æ ¸å¿ƒæ™ºèƒ½æ¨¡å—ï¼Œè´Ÿè´£å°†æ‹›æ ‡éœ€æ±‚ä¸ä¼ä¸šèƒ½åŠ›è¿›è¡Œè¯­ä¹‰åŒ¹é…ã€è¯„åˆ†å’Œå¯è§†åŒ–å±•ç¤ºï¼Œä¸ºæ ‡ä¹¦æ’°å†™æä¾›ç²¾å‡†çš„èƒ½åŠ›å¼•ç”¨å»ºè®®ã€‚

**æ ¸å¿ƒä»·å€¼**:
- å®ç°æ‹›æ ‡éœ€æ±‚ä¸ä¼ä¸šèƒ½åŠ›çš„æ™ºèƒ½åŒ¹é…
- è¯†åˆ«ä¼ä¸šç«äº‰ä¼˜åŠ¿å’Œèƒ½åŠ›å·®è·
- æä¾›æ™ºèƒ½æ¨èï¼ˆæ¡ˆä¾‹ã€æ¨¡æ¿ã€å›¢é˜Ÿï¼‰
- è¾…åŠ©æŠ•æ ‡å†³ç­–ï¼ˆä¸­æ ‡æ¦‚ç‡è¯„ä¼°ï¼‰

**æŠ€æœ¯æ¶æ„**:
```
æ‹›æ ‡éœ€æ±‚åˆ†æ â†’ å‘é‡æ£€ç´¢ + å…³é”®è¯åŒ¹é… â†’ ç»¼åˆè¯„åˆ†
        â†“
    èƒ½åŠ›åŒ¹é…çŸ©é˜µ
        â†“
ç«äº‰ä¼˜åŠ¿è¯†åˆ« â†’ å·®è·åˆ†æ â†’ æ”¹è¿›å»ºè®®
        â†“
    æ™ºèƒ½æ¨èå¼•æ“
```

---

### äºŒçº§ä»»åŠ¡ 4.1: éœ€æ±‚åŒ¹é…åˆ†æ

**å·¥ä½œé‡ä¼°ç®—**: 5 äººå¤©
**ä¼˜å…ˆçº§**: P1 - é«˜ä¼˜å…ˆçº§ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
**æŠ€æœ¯éš¾ç‚¹**:
- å¤šç»´åº¦åŒ¹é…ç®—æ³•è®¾è®¡
- åŒ¹é…åº¦è¯„åˆ†å‡†ç¡®æ€§
- å¯è§†åŒ–çŸ©é˜µå±•ç¤º

#### 1) æ•°æ®å®šä¹‰

##### Pydanticæ¨¡å‹
```python
# app/models/matching.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
from decimal import Decimal

class RequirementMatch(BaseModel):
    """éœ€æ±‚åŒ¹é…æ¨¡å‹"""
    requirement_id: str = Field(..., description="éœ€æ±‚ID")
    requirement_title: str = Field(..., description="éœ€æ±‚æ ‡é¢˜")
    requirement_type: str = Field(..., description="æŠ€æœ¯/å•†åŠ¡/åˆè§„")
    is_mandatory: bool = Field(..., description="æ˜¯å¦å¼ºåˆ¶è¦æ±‚")
    score_weight: Decimal = Field(..., description="è¯„åˆ†æƒé‡")

    # åŒ¹é…çš„èƒ½åŠ›
    matched_capabilities: List[Dict[str, Any]] = Field(default_factory=list, description="åŒ¹é…çš„èƒ½åŠ›åˆ—è¡¨")

    # åŒ¹é…åº¦è¯„åˆ†
    match_score: Decimal = Field(..., ge=0, le=100, description="åŒ¹é…åº¦åˆ†æ•° (0-100)")
    match_status: str = Field(..., description="matched|partial|unmatched")

    # åŒ¹é…è¯¦æƒ…
    match_method: str = Field(..., description="vector|keyword|hybrid")
    vector_similarity: Optional[Decimal] = Field(None, description="å‘é‡ç›¸ä¼¼åº¦")
    keyword_coverage: Optional[Decimal] = Field(None, description="å…³é”®è¯è¦†ç›–ç‡")

    # å»ºè®®
    suggestions: List[str] = Field(default_factory=list, description="æ”¹è¿›å»ºè®®")
    gap_analysis: Optional[str] = Field(None, description="å·®è·åˆ†æ")

class MatchingMatrix(BaseModel):
    """åŒ¹é…çŸ©é˜µ"""
    project_id: str = Field(..., description="é¡¹ç›®ID")
    organization_id: str = Field(..., description="ç»„ç»‡ID")

    # éœ€æ±‚åˆ—è¡¨
    requirements: List[RequirementMatch] = Field(default_factory=list)

    # æ•´ä½“åŒ¹é…åº¦
    overall_match_score: Decimal = Field(..., description="æ•´ä½“åŒ¹é…åº¦")
    mandatory_match_rate: Decimal = Field(..., description="å¼ºåˆ¶éœ€æ±‚åŒ¹é…ç‡")
    optional_match_rate: Decimal = Field(..., description="å¯é€‰éœ€æ±‚åŒ¹é…ç‡")

    # ç»Ÿè®¡ä¿¡æ¯
    total_requirements: int = Field(..., description="æ€»éœ€æ±‚æ•°")
    matched_count: int = Field(..., description="å®Œå…¨åŒ¹é…æ•°")
    partial_count: int = Field(..., description="éƒ¨åˆ†åŒ¹é…æ•°")
    unmatched_count: int = Field(..., description="æœªåŒ¹é…æ•°")

    # ç”Ÿæˆæ—¶é—´
    generated_at: datetime = Field(default_factory=datetime.utcnow)

class MatchingRequest(BaseModel):
    """åŒ¹é…åˆ†æè¯·æ±‚"""
    project_id: str = Field(..., description="é¡¹ç›®ID")
    organization_id: str = Field(..., description="ç»„ç»‡ID")
    match_threshold: Decimal = Field(0.6, ge=0, le=1, description="åŒ¹é…é˜ˆå€¼")
    include_partial: bool = Field(True, description="æ˜¯å¦åŒ…å«éƒ¨åˆ†åŒ¹é…")
```

##### Javaå®ä½“
```java
// MatchingResult.java
@Data
@TableName("matching_results")
public class MatchingResult {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;

    private String projectId;
    private String organizationId;

    // åŒ¹é…åº¦ç»Ÿè®¡
    private BigDecimal overallMatchScore;
    private BigDecimal mandatoryMatchRate;
    private BigDecimal optionalMatchRate;

    // éœ€æ±‚ç»Ÿè®¡
    private Integer totalRequirements;
    private Integer matchedCount;
    private Integer partialCount;
    private Integer unmatchedCount;

    // åŒ¹é…è¯¦æƒ…ï¼ˆJSONBï¼‰
    @TableField(typeHandler = JacksonTypeHandler.class)
    private List<RequirementMatchDetail> matchDetails;

    // å»ºè®®ï¼ˆJSONBï¼‰
    @TableField(typeHandler = JacksonTypeHandler.class)
    private List<String> recommendations;

    private LocalDateTime generatedAt;
    private LocalDateTime createdAt;
}
```

##### æ•°æ®åº“è¡¨
```sql
CREATE TABLE matching_results (
    id UUID PRIMARY KEY,
    project_id UUID NOT NULL,
    organization_id UUID NOT NULL,

    -- åŒ¹é…åº¦ç»Ÿè®¡
    overall_match_score DECIMAL(5,2) NOT NULL,  -- 0-100
    mandatory_match_rate DECIMAL(5,2),
    optional_match_rate DECIMAL(5,2),

    -- éœ€æ±‚ç»Ÿè®¡
    total_requirements INTEGER NOT NULL,
    matched_count INTEGER DEFAULT 0,
    partial_count INTEGER DEFAULT 0,
    unmatched_count INTEGER DEFAULT 0,

    -- åŒ¹é…è¯¦æƒ…å’Œå»ºè®®ï¼ˆJSONBï¼‰
    match_details JSONB,
    recommendations JSONB,

    generated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE
);

CREATE INDEX idx_matching_results_project ON matching_results(project_id);
CREATE INDEX idx_matching_results_score ON matching_results(overall_match_score DESC);
```

**éªŒè¯æ ‡å‡†**:
- [ ] Pydanticæ¨¡å‹éªŒè¯é€šè¿‡
- [ ] è¯„åˆ†èŒƒå›´æ ¡éªŒæ­£ç¡® (0-100)
- [ ] æ•°æ®åº“è¡¨åˆ›å»ºæˆåŠŸ

#### 2) å‰ç«¯

```typescript
// src/components/Matching/MatchingMatrix.tsx
import { Card, Progress, Tag, Descriptions, Table, Space } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, ExclamationCircleOutlined } from '@ant-design/icons';
import { useState, useEffect } from 'react';

interface MatchingMatrixProps {
  projectId: string;
}

export default function MatchingMatrix({ projectId }: MatchingMatrixProps) {
  const [matchingData, setMatchingData] = useState<MatchingMatrix | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchMatchingData();
  }, [projectId]);

  const fetchMatchingData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`http://localhost:8001/api/v1/ai/match/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ project_id: projectId })
      });
      const result = await response.json();
      setMatchingData(result.data);
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: 'éœ€æ±‚',
      dataIndex: 'requirementTitle',
      width: 250,
      render: (text: string, record: RequirementMatch) => (
        <Space>
          {record.isMandatory && <Tag color="red">å¼ºåˆ¶</Tag>}
          <span>{text}</span>
        </Space>
      ),
    },
    {
      title: 'ç±»å‹',
      dataIndex: 'requirementType',
      width: 100,
      render: (type: string) => {
        const colorMap: Record<string, string> = {
          technical: 'blue',
          business: 'green',
          compliance: 'orange',
        };
        return <Tag color={colorMap[type]}>{type}</Tag>;
      },
    },
    {
      title: 'åŒ¹é…åº¦',
      dataIndex: 'matchScore',
      width: 150,
      render: (score: number, record: RequirementMatch) => {
        let status: 'success' | 'exception' | 'normal' = 'normal';
        let color = 'blue';

        if (score >= 80) {
          status = 'success';
          color = 'green';
        } else if (score < 60) {
          status = 'exception';
          color = 'red';
        }

        return (
          <Space>
            <Progress
              type="circle"
              percent={score}
              width={60}
              status={status}
              strokeColor={color}
            />
            <span>{score.toFixed(1)}%</span>
          </Space>
        );
      },
    },
    {
      title: 'åŒ¹é…çŠ¶æ€',
      dataIndex: 'matchStatus',
      width: 120,
      render: (status: string) => {
        const statusMap = {
          matched: { icon: <CheckCircleOutlined />, color: 'success', text: 'å·²åŒ¹é…' },
          partial: { icon: <ExclamationCircleOutlined />, color: 'warning', text: 'éƒ¨åˆ†åŒ¹é…' },
          unmatched: { icon: <CloseCircleOutlined />, color: 'error', text: 'æœªåŒ¹é…' },
        };
        const config = statusMap[status as keyof typeof statusMap];
        return (
          <Tag icon={config.icon} color={config.color}>
            {config.text}
          </Tag>
        );
      },
    },
    {
      title: 'åŒ¹é…èƒ½åŠ›',
      dataIndex: 'matchedCapabilities',
      width: 200,
      render: (capabilities: any[]) => (
        <Space direction="vertical" size="small">
          {capabilities.slice(0, 3).map((cap, idx) => (
            <Tag key={idx}>{cap.name} ({(cap.score * 100).toFixed(0)}%)</Tag>
          ))}
          {capabilities.length > 3 && <Tag>+{capabilities.length - 3} more</Tag>}
        </Space>
      ),
    },
    {
      title: 'æƒé‡',
      dataIndex: 'scoreWeight',
      width: 80,
      render: (weight: number) => `${(weight * 100).toFixed(0)}%`,
    },
    {
      title: 'å»ºè®®',
      dataIndex: 'suggestions',
      width: 200,
      render: (suggestions: string[]) => (
        <ul style={{ paddingLeft: 20, margin: 0 }}>
          {suggestions.map((s, idx) => (
            <li key={idx}>{s}</li>
          ))}
        </ul>
      ),
    },
  ];

  if (loading) {
    return <Card loading />;
  }

  if (!matchingData) {
    return <Card>æš‚æ— åŒ¹é…æ•°æ®</Card>;
  }

  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      {/* æ•´ä½“åŒ¹é…åº¦æ¦‚è§ˆ */}
      <Card title="æ•´ä½“åŒ¹é…åº¦">
        <Descriptions column={4}>
          <Descriptions.Item label="æ€»ä½“åŒ¹é…åº¦">
            <Progress
              type="dashboard"
              percent={matchingData.overallMatchScore}
              strokeColor={{
                '0%': '#108ee9',
                '100%': '#87d068',
              }}
            />
          </Descriptions.Item>
          <Descriptions.Item label="å¼ºåˆ¶éœ€æ±‚åŒ¹é…ç‡">
            <Progress
              percent={matchingData.mandatoryMatchRate}
              status={matchingData.mandatoryMatchRate >= 90 ? 'success' : 'exception'}
            />
          </Descriptions.Item>
          <Descriptions.Item label="å¯é€‰éœ€æ±‚åŒ¹é…ç‡">
            <Progress
              percent={matchingData.optionalMatchRate}
            />
          </Descriptions.Item>
          <Descriptions.Item label="éœ€æ±‚ç»Ÿè®¡">
            <Space>
              <Tag color="success">{matchingData.matchedCount} å·²åŒ¹é…</Tag>
              <Tag color="warning">{matchingData.partialCount} éƒ¨åˆ†</Tag>
              <Tag color="error">{matchingData.unmatchedCount} æœªåŒ¹é…</Tag>
            </Space>
          </Descriptions.Item>
        </Descriptions>
      </Card>

      {/* è¯¦ç»†åŒ¹é…çŸ©é˜µ */}
      <Card title="éœ€æ±‚åŒ¹é…æ˜ç»†">
        <Table
          dataSource={matchingData.requirements}
          columns={columns}
          rowKey="requirementId"
          pagination={false}
          scroll={{ x: 1200 }}
          rowClassName={(record) => {
            if (record.matchStatus === 'unmatched') return 'row-unmatched';
            if (record.matchStatus === 'partial') return 'row-partial';
            return 'row-matched';
          }}
        />
      </Card>
    </Space>
  );
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] åŒ¹é…çŸ©é˜µå¯è§†åŒ–å±•ç¤ºæ­£ç¡®
- [ ] è¿›åº¦æ¡é¢œè‰²æ ¹æ®åˆ†æ•°åŠ¨æ€å˜åŒ–
- [ ] è¡¨æ ¼è¡Œæ ·å¼æ ¹æ®åŒ¹é…çŠ¶æ€å˜åŒ–
- [ ] ç§»åŠ¨ç«¯å“åº”å¼å¸ƒå±€æ­£å¸¸

#### 3) Javaåç«¯

```java
@Service
@RequiredArgsConstructor
public class MatchingService {

    private final RestTemplate restTemplate;
    private final MatchingResultMapper matchingResultMapper;

    /**
     * è§¦å‘åŒ¹é…åˆ†æ
     * éœ€æ±‚ç¼–å·: REQ-AI-004
     */
    public MatchingResult triggerMatching(String projectId) {
        log.info("Triggering matching analysis for project: {}", projectId);

        // è°ƒç”¨Python AIæœåŠ¡æ‰§è¡ŒåŒ¹é…åˆ†æ
        String pythonAiUrl = "http://backend-python:8001/api/v1/ai/match/analyze";

        MatchingRequest request = MatchingRequest.builder()
            .projectId(projectId)
            .matchThreshold(0.6)
            .includePartial(true)
            .build();

        ResponseEntity<ApiResponse<MatchingMatrix>> response = restTemplate.postForEntity(
            pythonAiUrl,
            request,
            new ParameterizedTypeReference<ApiResponse<MatchingMatrix>>() {}
        );

        MatchingMatrix matrix = response.getBody().getData();

        // ä¿å­˜åŒ¹é…ç»“æœåˆ°æ•°æ®åº“
        MatchingResult result = new MatchingResult();
        result.setProjectId(projectId);
        result.setOrganizationId(matrix.getOrganizationId());
        result.setOverallMatchScore(matrix.getOverallMatchScore());
        result.setMandatoryMatchRate(matrix.getMandatoryMatchRate());
        result.setOptionalMatchRate(matrix.getOptionalMatchRate());
        result.setTotalRequirements(matrix.getTotalRequirements());
        result.setMatchedCount(matrix.getMatchedCount());
        result.setPartialCount(matrix.getPartialCount());
        result.setUnmatchedCount(matrix.getUnmatchedCount());
        result.setMatchDetails(convertMatchDetails(matrix.getRequirements()));
        result.setGeneratedAt(LocalDateTime.now());

        matchingResultMapper.insert(result);

        return result;
    }

    /**
     * è·å–åŒ¹é…ç»“æœ
     */
    public MatchingResult getMatchingResult(String projectId) {
        return matchingResultMapper.selectOne(
            new QueryWrapper<MatchingResult>()
                .eq("project_id", projectId)
                .orderByDesc("generated_at")
                .last("LIMIT 1")
        );
    }
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] èƒ½æˆåŠŸè°ƒç”¨Python AIæœåŠ¡
- [ ] åŒ¹é…ç»“æœèƒ½æ­£ç¡®ä¿å­˜åˆ°æ•°æ®åº“
- [ ] æŸ¥è¯¢æœ€æ–°åŒ¹é…ç»“æœåŠŸèƒ½æ­£å¸¸

#### 4) Pythonåç«¯

##### åŒ¹é…åˆ†ææœåŠ¡
```python
# app/services/ai/matching_service.py
from typing import List, Dict, Any
from app.models.matching import MatchingRequest, MatchingMatrix, RequirementMatch
from app.services.ai.hybrid_search_service import HybridSearchService
from app.services.ai.embedding_service import EmbeddingService
from decimal import Decimal
import httpx
import logging

logger = logging.getLogger(__name__)

class MatchingService:
    """æ™ºèƒ½åŒ¹é…åˆ†ææœåŠ¡
    éœ€æ±‚ç¼–å·: REQ-AI-004
    """

    def __init__(self):
        self.search_service = HybridSearchService()
        self.embedding_service = EmbeddingService()
        self.java_client = httpx.AsyncClient(base_url="http://backend-java:8080")

    async def analyze_matching(self, request: MatchingRequest) -> MatchingMatrix:
        """
        æ‰§è¡Œéœ€æ±‚åŒ¹é…åˆ†æ

        Args:
            request: åŒ¹é…åˆ†æè¯·æ±‚

        Returns:
            åŒ¹é…çŸ©é˜µ
        """
        logger.info(f"Analyzing matching for project: {request.project_id}")

        # 1. ä»JavaæœåŠ¡è·å–é¡¹ç›®éœ€æ±‚
        requirements = await self._fetch_requirements(request.project_id)

        # 2. å¯¹æ¯ä¸ªéœ€æ±‚è¿›è¡ŒåŒ¹é…åˆ†æ
        requirement_matches = []
        for req in requirements:
            match_result = await self._match_single_requirement(
                requirement=req,
                organization_id=request.organization_id,
                threshold=request.match_threshold
            )
            requirement_matches.append(match_result)

        # 3. è®¡ç®—æ•´ä½“åŒ¹é…åº¦
        overall_stats = self._calculate_overall_stats(requirement_matches)

        # 4. æ„å»ºåŒ¹é…çŸ©é˜µ
        matrix = MatchingMatrix(
            project_id=request.project_id,
            organization_id=request.organization_id,
            requirements=requirement_matches,
            overall_match_score=Decimal(overall_stats['overall_score']),
            mandatory_match_rate=Decimal(overall_stats['mandatory_rate']),
            optional_match_rate=Decimal(overall_stats['optional_rate']),
            total_requirements=len(requirements),
            matched_count=overall_stats['matched_count'],
            partial_count=overall_stats['partial_count'],
            unmatched_count=overall_stats['unmatched_count']
        )

        logger.info(f"Matching analysis completed. Overall score: {matrix.overall_match_score}")

        return matrix

    async def _fetch_requirements(self, project_id: str) -> List[Dict[str, Any]]:
        """ä»JavaæœåŠ¡è·å–é¡¹ç›®éœ€æ±‚"""
        response = await self.java_client.get(
            f"/api/v1/projects/{project_id}/requirements"
        )
        response.raise_for_status()
        return response.json()['data']

    async def _match_single_requirement(
        self,
        requirement: Dict[str, Any],
        organization_id: str,
        threshold: Decimal
    ) -> RequirementMatch:
        """
        åŒ¹é…å•ä¸ªéœ€æ±‚

        ç­–ç•¥:
        1. å‘é‡æ£€ç´¢ï¼ˆè¯­ä¹‰ç›¸ä¼¼åº¦ï¼Œæƒé‡60%ï¼‰
        2. å…³é”®è¯æ£€ç´¢ï¼ˆç²¾ç¡®åŒ¹é…ï¼Œæƒé‡40%ï¼‰
        3. ç»¼åˆè¯„åˆ†
        """
        req_text = f"{requirement['title']}: {requirement['description']}"

        # æ‰§è¡Œæ··åˆæ£€ç´¢
        from app.models.search import SearchRequest, SearchMode
        search_request = SearchRequest(
            query=req_text,
            organization_id=organization_id,
            search_mode=SearchMode.HYBRID,
            vector_weight=0.6,
            keyword_weight=0.4,
            enable_rerank=True,
            top_k=10
        )

        search_response = await self.search_service.search(search_request)

        # æå–åŒ¹é…çš„èƒ½åŠ›
        matched_capabilities = []
        for result in search_response.results:
            matched_capabilities.append({
                'capability_id': result.capability_id,
                'capability_type': result.capability_type,
                'name': result.name,
                'score': float(result.relevance_score),
                'vector_score': float(result.vector_score) if result.vector_score else None,
                'keyword_score': float(result.keyword_score) if result.keyword_score else None,
            })

        # è®¡ç®—åŒ¹é…åº¦
        if matched_capabilities:
            # ä½¿ç”¨æœ€ä½³åŒ¹é…çš„åˆ†æ•°
            best_score = matched_capabilities[0]['score'] * 100
            match_score = Decimal(best_score).quantize(Decimal('0.01'))

            # åˆ¤æ–­åŒ¹é…çŠ¶æ€
            if match_score >= 80:
                match_status = "matched"
            elif match_score >= float(threshold) * 100:
                match_status = "partial"
            else:
                match_status = "unmatched"
        else:
            match_score = Decimal(0)
            match_status = "unmatched"

        # ç”Ÿæˆæ”¹è¿›å»ºè®®
        suggestions = self._generate_suggestions(
            requirement=requirement,
            match_score=match_score,
            matched_capabilities=matched_capabilities
        )

        return RequirementMatch(
            requirement_id=requirement['id'],
            requirement_title=requirement['title'],
            requirement_type=requirement.get('requirement_type', 'technical'),
            is_mandatory=requirement.get('is_mandatory', False),
            score_weight=Decimal(requirement.get('score_weight', 1.0)),
            matched_capabilities=matched_capabilities,
            match_score=match_score,
            match_status=match_status,
            match_method="hybrid",
            vector_similarity=Decimal(matched_capabilities[0]['vector_score']) if matched_capabilities else None,
            keyword_coverage=Decimal(matched_capabilities[0]['keyword_score']) if matched_capabilities else None,
            suggestions=suggestions
        )

    def _calculate_overall_stats(
        self,
        requirement_matches: List[RequirementMatch]
    ) -> Dict[str, Any]:
        """è®¡ç®—æ•´ä½“åŒ¹é…ç»Ÿè®¡"""
        total = len(requirement_matches)
        matched_count = sum(1 for m in requirement_matches if m.match_status == 'matched')
        partial_count = sum(1 for m in requirement_matches if m.match_status == 'partial')
        unmatched_count = sum(1 for m in requirement_matches if m.match_status == 'unmatched')

        # åŠ æƒå¹³å‡åˆ†æ•°
        total_weighted_score = sum(
            float(m.match_score) * float(m.score_weight)
            for m in requirement_matches
        )
        total_weight = sum(float(m.score_weight) for m in requirement_matches)
        overall_score = total_weighted_score / total_weight if total_weight > 0 else 0

        # å¼ºåˆ¶éœ€æ±‚åŒ¹é…ç‡
        mandatory_matches = [m for m in requirement_matches if m.is_mandatory]
        if mandatory_matches:
            mandatory_matched = sum(
                1 for m in mandatory_matches
                if m.match_status in ['matched', 'partial']
            )
            mandatory_rate = (mandatory_matched / len(mandatory_matches)) * 100
        else:
            mandatory_rate = 100

        # å¯é€‰éœ€æ±‚åŒ¹é…ç‡
        optional_matches = [m for m in requirement_matches if not m.is_mandatory]
        if optional_matches:
            optional_matched = sum(
                1 for m in optional_matches
                if m.match_status in ['matched', 'partial']
            )
            optional_rate = (optional_matched / len(optional_matches)) * 100
        else:
            optional_rate = 100

        return {
            'overall_score': round(overall_score, 2),
            'mandatory_rate': round(mandatory_rate, 2),
            'optional_rate': round(optional_rate, 2),
            'matched_count': matched_count,
            'partial_count': partial_count,
            'unmatched_count': unmatched_count
        }

    def _generate_suggestions(
        self,
        requirement: Dict[str, Any],
        match_score: Decimal,
        matched_capabilities: List[Dict[str, Any]]
    ) -> List[str]:
        """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
        suggestions = []

        if match_score < 60:
            suggestions.append("å»ºè®®è¡¥å……ç›¸å…³èƒ½åŠ›æˆ–æ¡ˆä¾‹")
            if not matched_capabilities:
                suggestions.append("æœªæ‰¾åˆ°åŒ¹é…èƒ½åŠ›ï¼Œå»ºè®®æ·»åŠ ç›¸å…³äº§å“æˆ–æœåŠ¡")
        elif match_score < 80:
            suggestions.append("å­˜åœ¨éƒ¨åˆ†åŒ¹é…ï¼Œå»ºè®®å®Œå–„ç°æœ‰èƒ½åŠ›æè¿°")
            if matched_capabilities:
                best_match = matched_capabilities[0]
                suggestions.append(f"å¯å¼ºåŒ– '{best_match['name']}' çš„ç›¸å…³ç‰¹æ€§")

        if requirement.get('is_mandatory') and match_score < 90:
            suggestions.append("âš ï¸ å¼ºåˆ¶éœ€æ±‚ï¼Œå»ºè®®é‡ç‚¹å…³æ³¨")

        return suggestions

    async def close(self):
        """å…³é—­èµ„æº"""
        await self.java_client.aclose()
```

##### APIæ¥å£
```python
# app/api/v1/matching.py
from fastapi import APIRouter, HTTPException
from app.models.matching import MatchingRequest, MatchingMatrix
from app.services.ai.matching_service import MatchingService

router = APIRouter(prefix="/match", tags=["åŒ¹é…åˆ†æ"])

matching_service = MatchingService()

@router.post("/analyze", response_model=MatchingMatrix)
async def analyze_matching(request: MatchingRequest):
    """
    éœ€æ±‚åŒ¹é…åˆ†æ
    éœ€æ±‚ç¼–å·: REQ-AI-004

    åˆ†ææ‹›æ ‡éœ€æ±‚ä¸ä¼ä¸šèƒ½åŠ›çš„åŒ¹é…æƒ…å†µï¼Œç”ŸæˆåŒ¹é…çŸ©é˜µ
    """
    try:
        matrix = await matching_service.analyze_matching(request)
        return matrix
    except Exception as e:
        logger.error(f"Matching analysis failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ··åˆæ£€ç´¢ç®—æ³•æ­£ç¡®æ‰§è¡Œ
- [ ] åŒ¹é…åº¦è¯„åˆ†å‡†ç¡®ï¼ˆ0-100ï¼‰
- [ ] å¼ºåˆ¶/å¯é€‰éœ€æ±‚åˆ†åˆ«ç»Ÿè®¡æ­£ç¡®
- [ ] æ”¹è¿›å»ºè®®ç”Ÿæˆåˆç†

#### 5) éƒ¨ç½²

```yaml
# docker-compose.yml
services:
  matching-worker:
    build: ./backend-python
    command: celery -A app.tasks.celery_app worker --loglevel=info -Q matching
    environment:
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - JAVA_SERVICE_URL=http://backend-java:8080
```

**éªŒè¯æ ‡å‡†**:
- [ ] Workeræ­£å¸¸å¯åŠ¨
- [ ] èƒ½å¤„ç†åŒ¹é…åˆ†æä»»åŠ¡

---

### äºŒçº§ä»»åŠ¡ 4.2: ç«äº‰ä¼˜åŠ¿åˆ†æ

**å·¥ä½œé‡ä¼°ç®—**: 4 äººå¤©
**ä¼˜å…ˆçº§**: P2 - ä¸­ä¼˜å…ˆçº§
**æŠ€æœ¯éš¾ç‚¹**:
- ä¼˜åŠ¿è¯†åˆ«ç®—æ³•
- å·®è·é‡åŒ–åˆ†æ
- æ”¹è¿›å»ºè®®ç”Ÿæˆ

#### 1) æ•°æ®å®šä¹‰

##### Pydanticæ¨¡å‹
```python
# app/models/competitive_analysis.py
class CompetitiveAdvantage(BaseModel):
    """ç«äº‰ä¼˜åŠ¿æ¨¡å‹"""
    advantage_type: str = Field(..., description="æŠ€æœ¯/å•†åŠ¡/å“ç‰Œ/æˆæœ¬")
    title: str = Field(..., description="ä¼˜åŠ¿æ ‡é¢˜")
    description: str = Field(..., description="ä¼˜åŠ¿æè¿°")
    strength_score: Decimal = Field(..., ge=0, le=10, description="ä¼˜åŠ¿å¼ºåº¦ (0-10)")
    supporting_capabilities: List[str] = Field(default_factory=list, description="æ”¯æ’‘èƒ½åŠ›")
    supporting_cases: List[str] = Field(default_factory=list, description="æ”¯æ’‘æ¡ˆä¾‹")

class CompetitiveGap(BaseModel):
    """ç«äº‰å·®è·æ¨¡å‹"""
    gap_type: str = Field(..., description="èƒ½åŠ›/èµ„è´¨/ç»éªŒ/èµ„æº")
    requirement_id: str = Field(..., description="å…³è”éœ€æ±‚ID")
    gap_description: str = Field(..., description="å·®è·æè¿°")
    severity: str = Field(..., description="high|medium|low")
    impact_score: Decimal = Field(..., ge=0, le=10, description="å½±å“ç¨‹åº¦")
    improvement_suggestions: List[str] = Field(default_factory=list)
    estimated_effort: Optional[str] = Field(None, description="æ”¹è¿›é¢„ä¼°å·¥ä½œé‡")

class CompetitiveAnalysisResult(BaseModel):
    """ç«äº‰åˆ†æç»“æœ"""
    project_id: str
    organization_id: str

    # ä¼˜åŠ¿åˆ—è¡¨
    advantages: List[CompetitiveAdvantage] = Field(default_factory=list)
    advantage_summary: str = Field(..., description="ä¼˜åŠ¿æ€»ç»“")

    # å·®è·åˆ—è¡¨
    gaps: List[CompetitiveGap] = Field(default_factory=list)
    gap_summary: str = Field(..., description="å·®è·æ€»ç»“")

    # ç»¼åˆè¯„ä¼°
    competitiveness_score: Decimal = Field(..., description="ç«äº‰åŠ›è¯„åˆ† (0-100)")
    win_probability: Decimal = Field(..., description="ä¸­æ ‡æ¦‚ç‡ (0-100)")

    # æˆ˜ç•¥å»ºè®®
    strategic_recommendations: List[str] = Field(default_factory=list)

    generated_at: datetime = Field(default_factory=datetime.utcnow)
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ¨¡å‹éªŒè¯é€šè¿‡
- [ ] è¯„åˆ†èŒƒå›´æ­£ç¡®

#### 2) å‰ç«¯

```typescript
// src/components/Matching/CompetitiveAnalysis.tsx
export default function CompetitiveAnalysis({ projectId }: Props) {
  const [analysis, setAnalysis] = useState<CompetitiveAnalysisResult | null>(null);

  useEffect(() => {
    fetchAnalysis();
  }, [projectId]);

  const fetchAnalysis = async () => {
    const response = await fetch(`http://localhost:8001/api/v1/ai/match/competitive-analysis`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ project_id: projectId })
    });
    const result = await response.json();
    setAnalysis(result.data);
  };

  return (
    <Space direction="vertical" size="large" style={{ width: '100%' }}>
      {/* ç«äº‰åŠ›è¯„ä¼° */}
      <Card title="ç«äº‰åŠ›è¯„ä¼°">
        <Row gutter={24}>
          <Col span={12}>
            <Statistic
              title="ç«äº‰åŠ›è¯„åˆ†"
              value={analysis?.competitivenessScore}
              suffix="/ 100"
              valueStyle={{ color: getScoreColor(analysis?.competitivenessScore) }}
            />
          </Col>
          <Col span={12}>
            <Statistic
              title="ä¸­æ ‡æ¦‚ç‡"
              value={analysis?.winProbability}
              suffix="%"
              valueStyle={{ color: getScoreColor(analysis?.winProbability) }}
            />
          </Col>
        </Row>
      </Card>

      {/* ç«äº‰ä¼˜åŠ¿ */}
      <Card title="ç«äº‰ä¼˜åŠ¿">
        <List
          dataSource={analysis?.advantages}
          renderItem={(adv) => (
            <List.Item>
              <Card.Meta
                avatar={<Trophy style={{ fontSize: 32, color: '#faad14' }} />}
                title={<Space><Tag color="gold">{adv.advantageType}</Tag>{adv.title}</Space>}
                description={
                  <>
                    <p>{adv.description}</p>
                    <Space>
                      <Rate disabled value={adv.strengthScore / 2} />
                      <span>å¼ºåº¦: {adv.strengthScore}/10</span>
                    </Space>
                  </>
                }
              />
            </List.Item>
          )}
        />
      </Card>

      {/* èƒ½åŠ›å·®è· */}
      <Card title="èƒ½åŠ›å·®è·">
        <List
          dataSource={analysis?.gaps}
          renderItem={(gap) => (
            <List.Item>
              <Alert
                type={gap.severity === 'high' ? 'error' : gap.severity === 'medium' ? 'warning' : 'info'}
                message={<Space><Tag>{gap.gapType}</Tag>{gap.gapDescription}</Space>}
                description={
                  <Space direction="vertical">
                    <span>å½±å“ç¨‹åº¦: {gap.impactScore}/10</span>
                    <div>
                      <strong>æ”¹è¿›å»ºè®®:</strong>
                      <ul>
                        {gap.improvementSuggestions.map((s, idx) => (
                          <li key={idx}>{s}</li>
                        ))}
                      </ul>
                    </div>
                    {gap.estimatedEffort && (
                      <Tag color="blue">é¢„ä¼°å·¥ä½œé‡: {gap.estimatedEffort}</Tag>
                    )}
                  </Space>
                }
              />
            </List.Item>
          )}
        />
      </Card>

      {/* æˆ˜ç•¥å»ºè®® */}
      <Card title="æˆ˜ç•¥å»ºè®®">
        <Timeline>
          {analysis?.strategicRecommendations.map((rec, idx) => (
            <Timeline.Item key={idx}>{rec}</Timeline.Item>
          ))}
        </Timeline>
      </Card>
    </Space>
  );
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] ä¼˜åŠ¿å’Œå·®è·å¯è§†åŒ–å±•ç¤ºæ­£ç¡®
- [ ] è¯„åˆ†ä»ªè¡¨ç›˜é¢œè‰²åŠ¨æ€å˜åŒ–
- [ ] æˆ˜ç•¥å»ºè®®å±•ç¤ºæ¸…æ™°

#### 3) Javaåç«¯

```java
@Service
public class CompetitiveAnalysisService {

    /**
     * è§¦å‘ç«äº‰åˆ†æ
     * éœ€æ±‚ç¼–å·: REQ-AI-004
     */
    public CompetitiveAnalysisResult triggerAnalysis(String projectId) {
        // è°ƒç”¨Python AIæœåŠ¡
        String url = "http://backend-python:8001/api/v1/ai/match/competitive-analysis";

        CompetitiveAnalysisRequest request = CompetitiveAnalysisRequest.builder()
            .projectId(projectId)
            .build();

        ResponseEntity<ApiResponse<CompetitiveAnalysisResult>> response =
            restTemplate.postForEntity(url, request, ...);

        return response.getBody().getData();
    }
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] è°ƒç”¨PythonæœåŠ¡æˆåŠŸ
- [ ] ç»“æœæ­£ç¡®è¿”å›

#### 4) Pythonåç«¯

```python
# app/services/ai/competitive_analysis_service.py
class CompetitiveAnalysisService:
    """ç«äº‰åˆ†ææœåŠ¡"""

    async def analyze_competitiveness(
        self,
        project_id: str,
        organization_id: str
    ) -> CompetitiveAnalysisResult:
        """æ‰§è¡Œç«äº‰åˆ†æ"""

        # 1. è·å–åŒ¹é…çŸ©é˜µ
        matching_service = MatchingService()
        matching_matrix = await matching_service.analyze_matching(
            MatchingRequest(
                project_id=project_id,
                organization_id=organization_id
            )
        )

        # 2. è¯†åˆ«ç«äº‰ä¼˜åŠ¿
        advantages = await self._identify_advantages(matching_matrix)

        # 3. è¯†åˆ«èƒ½åŠ›å·®è·
        gaps = await self._identify_gaps(matching_matrix)

        # 4. è®¡ç®—ç«äº‰åŠ›è¯„åˆ†
        competitiveness_score = self._calculate_competitiveness_score(
            matching_matrix, advantages, gaps
        )

        # 5. ä¼°ç®—ä¸­æ ‡æ¦‚ç‡
        win_probability = self._estimate_win_probability(
            competitiveness_score, matching_matrix
        )

        # 6. ç”Ÿæˆæˆ˜ç•¥å»ºè®®
        strategic_recommendations = await self._generate_strategic_recommendations(
            advantages, gaps, matching_matrix
        )

        return CompetitiveAnalysisResult(
            project_id=project_id,
            organization_id=organization_id,
            advantages=advantages,
            advantage_summary=f"è¯†åˆ«åˆ° {len(advantages)} é¡¹ç«äº‰ä¼˜åŠ¿",
            gaps=gaps,
            gap_summary=f"å‘ç° {len(gaps)} é¡¹èƒ½åŠ›å·®è·",
            competitiveness_score=competitiveness_score,
            win_probability=win_probability,
            strategic_recommendations=strategic_recommendations
        )

    async def _identify_advantages(
        self,
        matching_matrix: MatchingMatrix
    ) -> List[CompetitiveAdvantage]:
        """è¯†åˆ«ç«äº‰ä¼˜åŠ¿ï¼ˆåŒ¹é…åº¦é«˜çš„éœ€æ±‚ï¼‰"""
        advantages = []

        for req_match in matching_matrix.requirements:
            if req_match.match_score >= 85:  # é«˜åŒ¹é…åº¦è§†ä¸ºä¼˜åŠ¿
                advantages.append(CompetitiveAdvantage(
                    advantage_type="technical",
                    title=f"åœ¨ '{req_match.requirement_title}' æ–¹é¢å…·æœ‰å¼ºå¤§èƒ½åŠ›",
                    description=f"åŒ¹é…åº¦é«˜è¾¾ {req_match.match_score}%",
                    strength_score=Decimal(req_match.match_score / 10),
                    supporting_capabilities=[
                        cap['name'] for cap in req_match.matched_capabilities[:3]
                    ]
                ))

        return advantages

    async def _identify_gaps(
        self,
        matching_matrix: MatchingMatrix
    ) -> List[CompetitiveGap]:
        """è¯†åˆ«èƒ½åŠ›å·®è·ï¼ˆåŒ¹é…åº¦ä½çš„éœ€æ±‚ï¼‰"""
        gaps = []

        for req_match in matching_matrix.requirements:
            if req_match.match_score < 60:  # ä½åŒ¹é…åº¦è§†ä¸ºå·®è·
                severity = "high" if req_match.is_mandatory else "medium"

                gaps.append(CompetitiveGap(
                    gap_type="capability",
                    requirement_id=req_match.requirement_id,
                    gap_description=f"åœ¨ '{req_match.requirement_title}' æ–¹é¢èƒ½åŠ›ä¸è¶³",
                    severity=severity,
                    impact_score=Decimal((100 - req_match.match_score) / 10),
                    improvement_suggestions=req_match.suggestions,
                    estimated_effort="2-4å‘¨" if severity == "high" else "1-2å‘¨"
                ))

        return gaps
```

**éªŒè¯æ ‡å‡†**:
- [ ] ä¼˜åŠ¿è¯†åˆ«å‡†ç¡®
- [ ] å·®è·åˆ†æåˆç†
- [ ] ä¸­æ ‡æ¦‚ç‡ä¼°ç®—æœ‰å‚è€ƒä»·å€¼

#### 5) éƒ¨ç½²

```yaml
# æ— ç‰¹æ®Šéƒ¨ç½²è¦æ±‚ï¼Œä½¿ç”¨ç°æœ‰PythonæœåŠ¡å³å¯
```

---

### äºŒçº§ä»»åŠ¡ 4.3: æ™ºèƒ½æ¨è

**å·¥ä½œé‡ä¼°ç®—**: 4 äººå¤©
**ä¼˜å…ˆçº§**: P2 - ä¸­ä¼˜å…ˆçº§
**æŠ€æœ¯éš¾ç‚¹**:
- æ¨èç®—æ³•è®¾è®¡
- å¤šç»´åº¦ç»¼åˆæ’åº
- ä¸ªæ€§åŒ–æ¨è

#### 1) æ•°æ®å®šä¹‰

```python
# app/models/recommendation.py
class RecommendationItem(BaseModel):
    """æ¨èé¡¹æ¨¡å‹"""
    item_id: str
    item_type: str = Field(..., description="case|template|person")
    title: str
    description: str
    relevance_score: Decimal = Field(..., ge=0, le=1)
    reason: str = Field(..., description="æ¨èç†ç”±")
    metadata: Dict[str, Any] = Field(default_factory=dict)

class RecommendationResult(BaseModel):
    """æ¨èç»“æœ"""
    project_id: str

    # æ¨èçš„æ¡ˆä¾‹
    recommended_cases: List[RecommendationItem] = Field(default_factory=list)

    # æ¨èçš„æ¨¡æ¿
    recommended_templates: List[RecommendationItem] = Field(default_factory=list)

    # æ¨èçš„å›¢é˜Ÿæˆå‘˜
    recommended_persons: List[RecommendationItem] = Field(default_factory=list)

    generated_at: datetime = Field(default_factory=datetime.utcnow)
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ¨¡å‹éªŒè¯é€šè¿‡

#### 2) å‰ç«¯

```typescript
// src/components/Matching/Recommendations.tsx
export default function Recommendations({ projectId }: Props) {
  const [recommendations, setRecommendations] = useState<RecommendationResult | null>(null);

  return (
    <Tabs>
      <TabPane tab="æ¨èæ¡ˆä¾‹" key="cases">
        <List
          dataSource={recommendations?.recommendedCases}
          renderItem={(item) => (
            <List.Item
              actions={[<Button type="link">å¼•ç”¨</Button>]}
            >
              <List.Item.Meta
                title={<Space><Tag color="blue">ç›¸å…³åº¦: {(item.relevanceScore * 100).toFixed(0)}%</Tag>{item.title}</Space>}
                description={
                  <>
                    <p>{item.description}</p>
                    <Tag color="green">æ¨èç†ç”±: {item.reason}</Tag>
                  </>
                }
              />
            </List.Item>
          )}
        />
      </TabPane>

      <TabPane tab="æ¨èæ¨¡æ¿" key="templates">
        {/* ç±»ä¼¼ç»“æ„ */}
      </TabPane>

      <TabPane tab="æ¨èå›¢é˜Ÿ" key="persons">
        {/* ç±»ä¼¼ç»“æ„ */}
      </TabPane>
    </Tabs>
  );
}
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ¨èåˆ—è¡¨æ­£å¸¸å±•ç¤º
- [ ] å¼•ç”¨åŠŸèƒ½æ­£å¸¸

#### 3) Javaåç«¯

```java
// ç±»ä¼¼å‰é¢çš„æœåŠ¡è°ƒç”¨æ¨¡å¼
```

#### 4) Pythonåç«¯

```python
# app/services/ai/recommendation_service.py
class RecommendationService:
    """æ™ºèƒ½æ¨èæœåŠ¡"""

    async def generate_recommendations(
        self,
        project_id: str,
        organization_id: str
    ) -> RecommendationResult:
        """ç”Ÿæˆæ¨è"""

        # 1. è·å–é¡¹ç›®éœ€æ±‚
        requirements = await self._fetch_requirements(project_id)

        # 2. æ¨èç›¸ä¼¼æ¡ˆä¾‹
        recommended_cases = await self._recommend_cases(
            requirements, organization_id
        )

        # 3. æ¨èåˆé€‚æ¨¡æ¿
        recommended_templates = await self._recommend_templates(
            requirements
        )

        # 4. æ¨èå›¢é˜Ÿæˆå‘˜
        recommended_persons = await self._recommend_persons(
            requirements, organization_id
        )

        return RecommendationResult(
            project_id=project_id,
            recommended_cases=recommended_cases,
            recommended_templates=recommended_templates,
            recommended_persons=recommended_persons
        )

    async def _recommend_cases(
        self,
        requirements: List[Dict[str, Any]],
        organization_id: str
    ) -> List[RecommendationItem]:
        """æ¨èç›¸ä¼¼æ¡ˆä¾‹ï¼ˆåŸºäºå‘é‡æ£€ç´¢ï¼‰"""
        # å°†éœ€æ±‚åˆå¹¶ä¸ºæŸ¥è¯¢æ–‡æœ¬
        query_text = "\n".join([
            f"{req['title']}: {req['description']}"
            for req in requirements
        ])

        # å‘é‡æ£€ç´¢
        from app.models.search import SearchRequest, SearchMode
        search_request = SearchRequest(
            query=query_text,
            organization_id=organization_id,
            capability_types=['case'],
            search_mode=SearchMode.HYBRID,
            top_k=5
        )

        search_response = await self.search_service.search(search_request)

        # è½¬æ¢ä¸ºæ¨èé¡¹
        recommendations = []
        for result in search_response.results:
            recommendations.append(RecommendationItem(
                item_id=result.capability_id,
                item_type="case",
                title=result.name,
                description=result.description,
                relevance_score=Decimal(result.relevance_score),
                reason=f"ä¸é¡¹ç›®éœ€æ±‚ç›¸ä¼¼åº¦ {(result.relevance_score * 100):.0f}%",
                metadata=result.metadata
            ))

        return recommendations
```

**éªŒè¯æ ‡å‡†**:
- [ ] æ¡ˆä¾‹æ¨èå‡†ç¡®
- [ ] æ¨¡æ¿æ¨èåˆç†
- [ ] äººå‘˜æ¨èåŒ¹é…éœ€æ±‚

#### 5) éƒ¨ç½²

```yaml
# æ— ç‰¹æ®Šéƒ¨ç½²è¦æ±‚
```

---

### æ¨¡å—æ€»ç»“

#### å®Œæˆè¿›åº¦ç»Ÿè®¡

**äºŒçº§ä»»åŠ¡å®Œæˆæƒ…å†µ**:
- 4.1 éœ€æ±‚åŒ¹é…åˆ†æ: âœ… è¯¦ç»†è§„åˆ’å®Œæˆï¼ˆ5äººå¤©ï¼‰
- 4.2 ç«äº‰ä¼˜åŠ¿åˆ†æ: âœ… è¯¦ç»†è§„åˆ’å®Œæˆï¼ˆ4äººå¤©ï¼‰
- 4.3 æ™ºèƒ½æ¨è: âœ… è¯¦ç»†è§„åˆ’å®Œæˆï¼ˆ4äººå¤©ï¼‰

**é¢„è®¡æ€»å·¥ä½œé‡**: 13 äººå¤©

### ç»†åŒ–æ•ˆæœ

âœ… **ç»†åŒ–å‰**: 3ä¸ªç²—ç²’åº¦å­ä»»åŠ¡
âœ… **ç»†åŒ–å**: æ¯ä¸ªå­ä»»åŠ¡æ‹†åˆ†ä¸º5ç±»åˆ«ï¼Œå…± 15+ å…·ä½“ä»»åŠ¡é¡¹

### å…³é”®ä¾èµ–

1. **AI-003 â†’ AI-004**: AI-004ä¾èµ–AI-003çš„å‘é‡æ£€ç´¢åŠŸèƒ½
2. **AI-001 â†’ AI-004**: ä¾èµ–æ–‡æ¡£è§£æå’Œéœ€æ±‚æå–
3. **åŒ¹é… â†’ æ¨è**: æ¨èç³»ç»Ÿä¾èµ–åŒ¹é…ç»“æœ

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ä¼˜å…ˆå¼€å§‹**: äºŒçº§ä»»åŠ¡ 4.1ï¼ˆéœ€æ±‚åŒ¹é…åˆ†æï¼‰
   - æ ¸å¿ƒåŠŸèƒ½ï¼Œä¼˜å…ˆçº§æœ€é«˜
   - æ˜¯ç«äº‰åˆ†æå’Œæ¨èçš„åŸºç¡€

2. **ä¾æ¬¡å¼€å‘**:
   - éœ€æ±‚åŒ¹é…ï¼ˆ4.1ï¼‰â†’ ç«äº‰åˆ†æï¼ˆ4.2ï¼‰â†’ æ™ºèƒ½æ¨èï¼ˆ4.3ï¼‰
   - æŒ‰ä¾èµ–å…³ç³»é¡ºåºå¼€å‘

---

**è¿”å›**: [ä»»åŠ¡è®¡åˆ’æ€»è§ˆ](./task-plan.md)

---
**âœ… æ‰€æœ‰AIæ¨¡å—å®Œæˆï¼**
