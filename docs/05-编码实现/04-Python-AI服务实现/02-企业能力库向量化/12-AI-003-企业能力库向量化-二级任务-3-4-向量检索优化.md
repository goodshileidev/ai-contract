# Python FastAPI AI 服务任务详细计划 - AI-003 - AI-003: 企业能力库向量化 - 二级任务 3.4: 向量检索优化

**工作量估算**: 3 人天
**优先级**: P2 - 高优先级（检索性能优化）
**技术难点**:
- 混合检索算法实现
- 检索结果重排序
- 查询性能优化

#### 1) 数据定义

##### 检索参数模型
```python
# app/models/search.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from enum import Enum

class SearchMode(str, Enum):
    """检索模式"""
    VECTOR_ONLY = "vector_only"          # 仅向量检索
    KEYWORD_ONLY = "keyword_only"        # 仅关键词检索
    HYBRID = "hybrid"                    # 混合检索

class RerankStrategy(str, Enum):
    """重排序策略"""
    RRF = "rrf"                          # Reciprocal Rank Fusion
    LINEAR_COMBINATION = "linear"         # 线性组合
    LLM_RERANK = "llm_rerank"            # LLM重排序

class SearchRequest(BaseModel):
    """检索请求"""
    query: str = Field(..., description="查询文本")
    organization_id: str = Field(..., description="组织ID")
    capability_types: Optional[List[str]] = Field(None, description="能力类型过滤")
    top_k: int = Field(10, ge=1, le=100, description="返回结果数量")

    # 检索模式
    search_mode: SearchMode = Field(SearchMode.HYBRID, description="检索模式")
    vector_weight: float = Field(0.7, ge=0.0, le=1.0, description="向量检索权重")
    keyword_weight: float = Field(0.3, ge=0.0, le=1.0, description="关键词检索权重")

    # 重排序
    enable_rerank: bool = Field(True, description="是否启用重排序")
    rerank_strategy: RerankStrategy = Field(RerankStrategy.RRF, description="重排序策略")
    rerank_top_k: int = Field(50, description="重排序候选数量")

    # 过滤条件
    filters: Optional[Dict[str, Any]] = Field(None, description="额外过滤条件")

class SearchResult(BaseModel):
    """检索结果"""
    capability_id: str
    capability_type: str
    name: str
    description: str
    relevance_score: float = Field(..., description="相关性分数")
    vector_score: Optional[float] = Field(None, description="向量相似度分数")
    keyword_score: Optional[float] = Field(None, description="关键词匹配分数")
    rerank_score: Optional[float] = Field(None, description="重排序分数")
    metadata: Dict[str, Any] = Field(default_factory=dict)

class SearchResponse(BaseModel):
    """检索响应"""
    query: str
    results: List[SearchResult]
    total_results: int
    search_time_ms: float
    search_mode: SearchMode
    rerank_applied: bool
```

**验证标准**:
- [ ] 检索参数验证通过
- [ ] 权重和参数范围校验正确

#### 2) 前端

```typescript
// src/components/CapabilitySearch/index.tsx
import { Input, Select, Slider, Switch, Space, Card } from 'antd';
import { SearchOutlined } from '@ant-design/icons';
import { useState } from 'react';

interface SearchPanelProps {
  onSearch: (params: SearchParams) => void;
}

export default function CapabilitySearchPanel({ onSearch }: SearchPanelProps) {
  const [query, setQuery] = useState('');
  const [searchMode, setSearchMode] = useState<'hybrid' | 'vector_only' | 'keyword_only'>('hybrid');
  const [vectorWeight, setVectorWeight] = useState(0.7);
  const [enableRerank, setEnableRerank] = useState(true);
  const [rerankStrategy, setRerankStrategy] = useState<'rrf' | 'linear' | 'llm_rerank'>('rrf');

  const handleSearch = () => {
    onSearch({
      query,
      search_mode: searchMode,
      vector_weight: vectorWeight,
      keyword_weight: 1 - vectorWeight,
      enable_rerank: enableRerank,
      rerank_strategy: rerankStrategy,
      top_k: 10,
    });
  };

  return (
    <Card title="能力检索配置">
      <Space direction="vertical" style={{ width: '100%' }} size="large">
        {/* 查询输入 */}
        <Input.Search
          placeholder="输入查询需求..."
          value={query}
          onChange={e => setQuery(e.target.value)}
          onSearch={handleSearch}
          enterButton={<SearchOutlined />}
          size="large"
        />

        {/* 检索模式 */}
        <div>
          <label>检索模式：</label>
          <Select
            value={searchMode}
            onChange={setSearchMode}
            style={{ width: 200 }}
            options={[
              { label: '混合检索（推荐）', value: 'hybrid' },
              { label: '仅向量检索', value: 'vector_only' },
              { label: '仅关键词检索', value: 'keyword_only' },
            ]}
          />
        </div>

        {/* 权重调整（仅混合模式） */}
        {searchMode === 'hybrid' && (
          <div>
            <label>向量检索权重：{vectorWeight.toFixed(1)}</label>
            <Slider
              min={0}
              max={1}
              step={0.1}
              value={vectorWeight}
              onChange={setVectorWeight}
              marks={{
                0: '关键词',
                0.5: '平衡',
                1: '向量',
              }}
            />
          </div>
        )}

        {/* 重排序配置 */}
        <div>
          <Space>
            <label>启用重排序：</label>
            <Switch checked={enableRerank} onChange={setEnableRerank} />
          </Space>
        </div>

        {enableRerank && (
          <div>
            <label>重排序策略：</label>
            <Select
              value={rerankStrategy}
              onChange={setRerankStrategy}
              style={{ width: 200 }}
              options={[
                { label: 'RRF（倒数排名融合）', value: 'rrf' },
                { label: '线性组合', value: 'linear' },
                { label: 'LLM重排序', value: 'llm_rerank' },
              ]}
            />
          </div>
        )}
      </Space>
    </Card>
  );
}

// 搜索结果展示组件
function SearchResults({ results }: { results: SearchResult[] }) {
  return (
    <List
      dataSource={results}
      renderItem={(item) => (
        <List.Item>
          <Card hoverable>
            <Card.Meta
              title={
                <Space>
                  <Tag color="blue">{item.capabilityType}</Tag>
                  <span>{item.name}</span>
                  <Tag color="green">匹配度: {(item.relevanceScore * 100).toFixed(1)}%</Tag>
                </Space>
              }
              description={item.description}
            />
            <div style={{ marginTop: 16 }}>
              <Space>
                {item.vectorScore && (
                  <Tag>向量分: {item.vectorScore.toFixed(3)}</Tag>
                )}
                {item.keywordScore && (
                  <Tag>关键词分: {item.keywordScore.toFixed(3)}</Tag>
                )}
                {item.rerankScore && (
                  <Tag color="orange">重排序分: {item.rerankScore.toFixed(3)}</Tag>
                )}
              </Space>
            </div>
          </Card>
        </List.Item>
      )}
    />
  );
}
```

**验证标准**:
- [ ] 检索配置面板交互正常
- [ ] 权重滑块实时更新
- [ ] 搜索结果正确展示各项分数

#### 3) Java后端

```java
// 检索配置管理
@Service
public class SearchConfigService {

    /**
     * 保存用户的检索偏好
     */
    public void saveSearchPreference(String userId, SearchPreference preference) {
        // 保存到Redis
        String key = "search:preference:" + userId;
        redisTemplate.opsForValue().set(key, preference, 7, TimeUnit.DAYS);
    }

    /**
     * 获取用户的检索偏好
     */
    public SearchPreference getSearchPreference(String userId) {
        String key = "search:preference:" + userId;
        SearchPreference preference = redisTemplate.opsForValue().get(key);

        if (preference == null) {
            // 返回默认配置
            preference = SearchPreference.builder()
                .searchMode("hybrid")
                .vectorWeight(0.7)
                .keywordWeight(0.3)
                .enableRerank(true)
                .rerankStrategy("rrf")
                .build();
        }

        return preference;
    }
}
```

**验证标准**:
- [ ] 用户偏好能正确保存和读取
- [ ] Redis缓存正常工作

#### 4) Python后端

##### 混合检索服务
```python
# app/services/ai/hybrid_search_service.py
from typing import List, Dict, Any
from app.models.search import SearchRequest, SearchResponse, SearchResult, SearchMode, RerankStrategy
from app.services.ai.elasticsearch_store import ElasticsearchVectorStore
from app.services.ai.embedding_service import EmbeddingService
import time
import logging

logger = logging.getLogger(__name__)

class HybridSearchService:
    """混合检索服务
    需求编号: REQ-AI-003
    实现向量检索+关键词检索+结果重排序
    """

    def __init__(self):
        self.embedding_service = EmbeddingService()
        self.es_store = ElasticsearchVectorStore()

    async def search(self, request: SearchRequest) -> SearchResponse:
        """
        执行混合检索

        Args:
            request: 检索请求

        Returns:
            检索结果
        """
        start_time = time.time()

        logger.info(f"Hybrid search: query='{request.query}', mode={request.search_mode}")

        # 1. 根据检索模式执行不同的检索策略
        if request.search_mode == SearchMode.VECTOR_ONLY:
            results = await self._vector_search(request)
        elif request.search_mode == SearchMode.KEYWORD_ONLY:
            results = await self._keyword_search(request)
        else:  # HYBRID
            results = await self._hybrid_search(request)

        # 2. 重排序（如果启用）
        if request.enable_rerank and len(results) > 0:
            results = await self._rerank_results(
                query=request.query,
                results=results,
                strategy=request.rerank_strategy,
                top_k=request.top_k
            )

        # 3. 取Top-K
        results = results[:request.top_k]

        search_time_ms = (time.time() - start_time) * 1000

        logger.info(f"Search completed: {len(results)} results in {search_time_ms:.2f}ms")

        return SearchResponse(
            query=request.query,
            results=results,
            total_results=len(results),
            search_time_ms=search_time_ms,
            search_mode=request.search_mode,
            rerank_applied=request.enable_rerank
        )

    async def _vector_search(self, request: SearchRequest) -> List[SearchResult]:
        """纯向量检索"""
        # 1. 生成查询向量
        query_embedding = await self.embedding_service.embed_text(request.query)

        # 2. Elasticsearch kNN检索
        es_results = await self.es_store.search(
            query_embedding=query_embedding,
            top_k=request.rerank_top_k if request.enable_rerank else request.top_k,
            filter_dict={
                'organization_id': request.organization_id,
                'is_active': True,
                **(request.filters or {})
            }
        )

        # 3. 转换为SearchResult
        results = []
        for es_result in es_results:
            results.append(SearchResult(
                capability_id=es_result['id'],
                capability_type=es_result['metadata'].get('capability_type', 'unknown'),
                name=es_result['metadata'].get('name', ''),
                description=es_result['content'],
                relevance_score=es_result['score'],
                vector_score=es_result['score'],
                metadata=es_result['metadata']
            ))

        return results

    async def _keyword_search(self, request: SearchRequest) -> List[SearchResult]:
        """纯关键词检索"""
        # 使用Elasticsearch的全文搜索
        query_body = {
            "query": {
                "bool": {
                    "must": [
                        {
                            "multi_match": {
                                "query": request.query,
                                "fields": ["name^3", "description^2", "features", "advantages"],
                                "type": "best_fields",
                                "operator": "or"
                            }
                        }
                    ],
                    "filter": [
                        {"term": {"organization_id": request.organization_id}},
                        {"term": {"is_active": True}}
                    ]
                }
            },
            "size": request.rerank_top_k if request.enable_rerank else request.top_k
        }

        # 添加额外过滤条件
        if request.filters:
            for key, value in request.filters.items():
                query_body["query"]["bool"]["filter"].append({"term": {key: value}})

        # 执行搜索
        response = await self.es_store.es_client.search(
            index="capabilities",
            body=query_body
        )

        # 转换结果
        results = []
        max_score = response['hits']['max_score'] if response['hits']['max_score'] else 1.0

        for hit in response['hits']['hits']:
            results.append(SearchResult(
                capability_id=hit['_source']['capability_id'],
                capability_type=hit['_source']['capability_type'],
                name=hit['_source']['name'],
                description=hit['_source']['description'],
                relevance_score=hit['_score'] / max_score,  # 归一化
                keyword_score=hit['_score'] / max_score,
                metadata=hit['_source']
            ))

        return results

    async def _hybrid_search(self, request: SearchRequest) -> List[SearchResult]:
        """
        混合检索：向量检索 + 关键词检索 + 分数融合
        """
        # 1. 并行执行向量检索和关键词检索
        vector_results = await self._vector_search(request)
        keyword_results = await self._keyword_search(request)

        # 2. 结果融合
        # 创建ID到结果的映射
        combined_results = {}

        # 添加向量检索结果
        for result in vector_results:
            combined_results[result.capability_id] = result

        # 合并关键词检索结果
        for keyword_result in keyword_results:
            cap_id = keyword_result.capability_id

            if cap_id in combined_results:
                # 已存在，合并分数
                vector_result = combined_results[cap_id]

                # 加权组合
                combined_score = (
                    vector_result.vector_score * request.vector_weight +
                    keyword_result.keyword_score * request.keyword_weight
                )

                vector_result.relevance_score = combined_score
                vector_result.keyword_score = keyword_result.keyword_score
            else:
                # 新结果，只有关键词分数
                keyword_result.relevance_score = keyword_result.keyword_score * request.keyword_weight
                combined_results[cap_id] = keyword_result

        # 3. 按综合分数排序
        sorted_results = sorted(
            combined_results.values(),
            key=lambda x: x.relevance_score,
            reverse=True
        )

        return sorted_results

    async def _rerank_results(
        self,
        query: str,
        results: List[SearchResult],
        strategy: RerankStrategy,
        top_k: int
    ) -> List[SearchResult]:
        """
        重排序

        Args:
            query: 查询文本
            results: 初步检索结果
            strategy: 重排序策略
            top_k: 最终返回数量

        Returns:
            重排序后的结果
        """
        logger.info(f"Reranking {len(results)} results with strategy: {strategy}")

        if strategy == RerankStrategy.RRF:
            # Reciprocal Rank Fusion
            return self._rrf_rerank(results, top_k)
        elif strategy == RerankStrategy.LINEAR_COMBINATION:
            # 线性组合（已在hybrid_search中实现）
            return results[:top_k]
        elif strategy == RerankStrategy.LLM_RERANK:
            # LLM重排序
            return await self._llm_rerank(query, results, top_k)
        else:
            return results[:top_k]

    def _rrf_rerank(
        self,
        results: List[SearchResult],
        top_k: int,
        k: int = 60
    ) -> List[SearchResult]:
        """
        RRF重排序（Reciprocal Rank Fusion）

        公式: RRF(d) = Σ 1 / (k + rank_i(d))
        其中 rank_i(d) 是文档d在第i个排序列表中的排名

        Args:
            results: 检索结果
            top_k: 返回数量
            k: RRF参数，通常取60

        Returns:
            重排序后的结果
        """
        # 分别获取向量排序和关键词排序
        vector_ranked = sorted(
            [r for r in results if r.vector_score is not None],
            key=lambda x: x.vector_score,
            reverse=True
        )
        keyword_ranked = sorted(
            [r for r in results if r.keyword_score is not None],
            key=lambda x: x.keyword_score,
            reverse=True
        )

        # 计算RRF分数
        rrf_scores = {}

        for rank, result in enumerate(vector_ranked):
            cap_id = result.capability_id
            rrf_scores[cap_id] = rrf_scores.get(cap_id, 0) + 1 / (k + rank + 1)

        for rank, result in enumerate(keyword_ranked):
            cap_id = result.capability_id
            rrf_scores[cap_id] = rrf_scores.get(cap_id, 0) + 1 / (k + rank + 1)

        # 更新分数并排序
        for result in results:
            if result.capability_id in rrf_scores:
                result.rerank_score = rrf_scores[result.capability_id]
                result.relevance_score = result.rerank_score  # 使用RRF分数作为最终相关性分数

        # 按RRF分数排序
        reranked = sorted(
            results,
            key=lambda x: x.rerank_score if x.rerank_score else 0,
            reverse=True
        )

        return reranked[:top_k]

    async def _llm_rerank(
        self,
        query: str,
        results: List[SearchResult],
        top_k: int
    ) -> List[SearchResult]:
        """
        LLM重排序
        使用GPT模型评估每个结果与查询的相关性
        """
        # TODO: 实现LLM重排序
        # 使用GPT-4评估相关性
        logger.warning("LLM rerank not implemented yet, falling back to RRF")
        return self._rrf_rerank(results, top_k)
```

##### API接口
```python
# app/api/v1/search.py
from fastapi import APIRouter, HTTPException
from app.models.search import SearchRequest, SearchResponse
from app.services.ai.hybrid_search_service import HybridSearchService

router = APIRouter(prefix="/search", tags=["检索"])

search_service = HybridSearchService()

@router.post("/capabilities", response_model=SearchResponse)
async def search_capabilities(request: SearchRequest):
    """
    能力检索
    需求编号: REQ-AI-003

    支持三种检索模式:
    - vector_only: 仅向量检索（语义搜索）
    - keyword_only: 仅关键词检索（全文搜索）
    - hybrid: 混合检索（推荐）

    支持三种重排序策略:
    - rrf: Reciprocal Rank Fusion（倒数排名融合）
    - linear: 线性组合
    - llm_rerank: LLM重排序（使用GPT评估相关性）
    """
    try:
        response = await search_service.search(request)
        return response
    except Exception as e:
        logger.error(f"Search failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

**验证标准**:
- [ ] 三种检索模式都能正常工作
- [ ] RRF重排序算法正确实现
- [ ] 分数归一化和融合正确
- [ ] 检索性能满足要求（<500ms）

#### 5) 部署

##### Elasticsearch索引优化
```json
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 2,
    "index": {
      "similarity": {
        "custom_bm25": {
          "type": "BM25",
          "b": 0.75,
          "k1": 1.2
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart",
        "similarity": "custom_bm25"
      },
      "description": {
        "type": "text",
        "analyzer": "ik_max_word",
        "search_analyzer": "ik_smart"
      },
      "embedding": {
        "type": "dense_vector",
        "dims": 1536,
        "index": true,
        "similarity": "cosine",
        "index_options": {
          "type": "hnsw",
          "m": 16,
          "ef_construction": 100
        }
      }
    }
  }
}
```

##### 性能监控
```python
# app/middleware/search_metrics.py
from prometheus_client import Counter, Histogram
import time

# 指标定义
search_requests = Counter('search_requests_total', 'Total search requests', ['search_mode'])
search_latency = Histogram('search_latency_seconds', 'Search latency', ['search_mode'])
search_result_count = Histogram('search_result_count', 'Number of search results')

async def track_search_metrics(request: SearchRequest, response: SearchResponse):
    """记录检索指标"""
    search_requests.labels(search_mode=request.search_mode).inc()
    search_latency.labels(search_mode=request.search_mode).observe(
        response.search_time_ms / 1000
    )
    search_result_count.observe(len(response.results))
```

**验证标准**:
- [ ] Elasticsearch索引优化配置生效
- [ ] 监控指标正常采集
- [ ] Grafana仪表板能展示检索性能

---
